C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 1   


C51 COMPILER V9.03, COMPILATION OF MODULE CORE_SCAN
OBJECT MODULE PLACED IN Code\CORE\CORE_SCAN.OBJ
COMPILER INVOKED BY: C:\Program Files\KeilC\C51\BIN\C51.exe Code\CORE\CORE_SCAN.C LA WL(1) CD OT(9,SIZE) NOAREGS OR INCD
                    -IR(.\Code\CORE\INCLUDE\;.\Code\OEM\INCLUDE\;.\Code\CHIP\INCLUDE\;.\Code\API\INCLUDE\)

line level    source

   1          /*-----------------------------------------------------------------------------
   2           * TITLE: CORE_SCN.C - code to handle local keyboard scanning.
   3           *
   4           * Copyright (c) 1983-2007, Insyde Software Corporation. All Rights Reserved.
   5           *
   6           * You may not reproduce, distribute, publish, display, perform, modify, adapt,
   7           * transmit, broadcast, present, recite, release, license or otherwise exploit
   8           * any part of this publication in any form, by any means, without the prior
   9           * written permission of Insyde Software Corporation.
  10           *---------------------------------------------------------------------------*/
  11           
  12          #include <CORE_INCLUDE.H>
  13          #include <OEM_INCLUDE.H>
  14          
  15          //*******************************************************
  16          #ifndef KB_HW_KeyScan   // Firmware scan keyboard
  17          //******************************************************* 
  18          void CapDelay(void)
  19          {
  20   1          WNCKR = 0x00;               // Delay 15.26 us
  21   1          WNCKR = 0x00;               // Delay 15.26 us       
  22   1      }
  23          
  24          /* ----------------------------------------------------------------------------
  25           * FUNCTION:   scan_keys
  26           *
  27           * Scan key matrix once.
  28           *
  29           * Return: value != 0, scan activity detected, scan again later.
  30           *         value  = 0, no scan activity detected.
  31           * ------------------------------------------------------------------------- */
  32          BYTE scan_keys(void)
  33          {
  34   1              BYTE result;
  35   1              result = FALSE;
  36   1              
  37   1          scan.saf_make = 0;
  38   1          scan.saf_break = 0;
  39   1          scan.saf_keys = 0;
  40   1      
  41   1              if (typematic.byte) 
  42   1              {
  43   2              check_tm(typematic);    // Check typematic. 
  44   2              }
  45   1      
  46   1              if (new_keyh.byte)              // Exist Debounce key? 
  47   1              {                                               // Yes, bounding. 
  48   2              scan.saf_make = 1;      // Set debounce make bit. 
  49   2              debounce_key();
  50   2              result = TRUE;
  51   2              }
  52   1          
  53   1          if (!result)                                // Otherwise, scan all. 
  54   1          {  
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 2   

  55   2              for (ITempB03=0;ITempB03<16;ITempB03++)
  56   2              {
  57   3                      Write_Strobe(ITempB03);
  58   3                              CapDelay();                                                             
  59   3                      ITempB02 = KSI;         // Read in KI 0 - 7 sense line data. */
  60   3                  ITempB02 = (~ITempB02) ^ bscan_matrix[ITempB03];
  61   3                  if (ITempB02 != 0) 
  62   3                      {
  63   4                      check_scan(ITempB02, ITempB03); 
  64   4                      }
  65   3      
  66   3                  if (bscan_matrix[ITempB03]) 
  67   3                      {                                                       // Here, if current still active. 
  68   4                      scan.saf_keys = 1;      // Set keys active bits. Check all key release. 
  69   4                  }   
  70   3                              KSOL=0xFF;      
  71   3                              KSOH1=0xFF;
  72   3              }
  73   2                                                                              // If ghost exist, make key clear.
  74   2              if (new_keyl.field.ghost == 1)
  75   2              {  
  76   3                  new_keyl.field.ghost = 0;   // Ghost flag is set. Clear it.
  77   3                  ITempB01 = new_keyl.byte & 7;
  78   3                  if (ITempB01 == 0)
  79   3                  {  
  80   4                      ITempB01 = Byte_Mask((BYTE) (new_keyh.field.input));
  81   4                      ITempB01 = ITempB01 & diode_key; 
  82   4                  }
  83   3      
  84   3                  if (ITempB01 == 0)
  85   3                  {   
  86   4                      new_keyh.byte = 0;      // Clear new key. 
  87   4                      new_keyl.byte = 0;
  88   4                  }
  89   3              } 
  90   2          }
  91   1      
  92   1              return((BYTE) (scan.saf_make + scan.saf_break + scan.saf_keys));
  93   1      }
  94          
  95          /* ----------------------------------------------------------------------------
  96           * FUNCTION: Write_Strobe
  97           *
  98           * Writes the scan matrix KSO[15:0] lines based on Scan Line bit number.
  99           *
 100           * KSO[15:0] will be all floats or open except for the bit corresponding to
 101           * the Scan Line number.  This bit will be low to be detected by the sense
 102           * line input port later.
 103           *
 104           * Config.Msk_Strobe_H and Config.Msk_Strobe_L specify which of the 16 bits on
 105           * the port are used for the scanner.  (1 = Scanner, 0 = Other OEM function).
 106           * This allows port pins which are not used for the scanner output lines to be
 107           * used for something else.
 108           *
 109           * Input: Scan line number.
 110           * ------------------------------------------------------------------------- */
 111          void Write_Strobe(BYTE scan_line_num)
 112          {
 113   1              if (scan_line_num<8)
 114   1              {
 115   2              KSOL=~(0x01<<scan_line_num);
 116   2              KSOH1=0xFF;
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 3   

 117   2              }
 118   1              else
 119   1              {
 120   2              KSOL=0xFF;
 121   2                      KSOH1=~(0x01<<(scan_line_num-0x08));
 122   2              } 
 123   1      
 124   1              if(ExtendMatrix)
 125   1              {
 126   2                      KSOH2 = 0xFF;
 127   2                      Hook_SetGPIOScanPinH();
 128   2              }
 129   1      }
 130          
 131          /* ----------------------------------------------------------------------------
 132           * FUNCTION: check_scan
 133           *
 134           * Input:
 135           *     changes = Any bit set indicates there is a difference in state from
 136           *         last KSI to this KSI.
 137           *     scan_address = Address of strobe line that was low when changes was
 138           *         computed.
 139           *
 140           * NOTE:  For the shift and bit test of "changes" to work, "changes" MUST be
 141           * unsigned.  (Right shifting an unsigned quantity fills vacated bits with
 142           * zeros.  Right shifting a signed quantity will fill vacated bits with sign
 143           * bits on some machines and zero bits on others.)
 144           * ------------------------------------------------------------------------- */
 145          static void check_scan(BYTE changes, BYTE scan_address)
 146          {
 147   1          BYTE flag;
 148   1          BYTE change_make_key;
 149   1          BYTE bit_num; 
 150   1           
 151   1              flag = FALSE;                                   // Simple Matrix. 
 152   1              if (new_keyl.field.ghost == 1)
 153   1              {
 154   2              flag = TRUE;
 155   2              }
 156   1              else
 157   1              {   /* Find 0 -> 1 's. */
 158   2                      change_make_key = changes & ~bscan_matrix[scan_address];
 159   2              if (change_make_key == 0) 
 160   2                      {
 161   3                      flag = FALSE;
 162   3              }
 163   2                      else if (find_paths(change_make_key, scan_address)) 
 164   2                      {
 165   3                      flag = TRUE;    /* TRUE if ghost keys. */
 166   3              }
 167   2              }
 168   1      
 169   1              if (flag)
 170   1              {   /* Ghost exists. */
 171   2                      new_keyl.field.ghost = 1;  /* Set ghost flag. */
 172   2              /* Only look at 1 -> 0 transition & diode key always no ghost. */
 173   2              changes &= bscan_matrix[scan_address] | diode_key;
 174   2              }
 175   1      
 176   1          bit_num = 0;
 177   1          while (changes != 0)
 178   1          {   
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 4   

 179   2              if (changes & 0x01)     /* Look at changes 1 bit at a time. */
 180   2                      {
 181   3                  cscfnd(bit_num, scan_address);
 182   3              }
 183   2              bit_num++;
 184   2              changes = changes >> 1; /* Shift bit out (and a zero bit in) to check next bit. */
 185   2          }
 186   1      }
 187          
 188          /* ----------------------------------------------------------------------------
 189           * FUNCTION:   cscfnd
 190           *
 191           * Find changed bit.  This subroutine is called for each bit in this KSI that
 192           * is different from last KSI.
 193           * ------------------------------------------------------------------------- */
 194          static void cscfnd(BYTE bit_num, BYTE scan_address)
 195          {
 196   1          if (bscan_matrix[scan_address] & Byte_Mask(bit_num))
 197   1          {  
 198   2              if (scan.saf_break == 0) 
 199   2                      {
 200   3                  scan.saf_break = 1;
 201   3                  setup_debounce(bit_num, scan_address, BREAK_EVENT);
 202   3              }
 203   2          }
 204   1          else
 205   1          {   
 206   2              if (scan.saf_make == 0) 
 207   2                      {
 208   3                  scan.saf_make = 1;
 209   3                  setup_debounce(bit_num, scan_address, MAKE_EVENT);
 210   3              }
 211   2          } 
 212   1      }
 213          
 214          /* ----------------------------------------------------------------------------
 215           * FUNCTION:   setup_debounce
 216           *
 217           * Input:
 218           *     scan_address = number of bit of KO.
 219           *     bit_num = number of bit that changed from last KI to this KI for KO.
 220           *     event = contact event (MAKE_EVENT or BREAK_EVENT).
 221           * ------------------------------------------------------------------------- */
 222          static void setup_debounce(BYTE bit_num, BYTE scan_address, BYTE event)
 223          {
 224   1          new_keyh.field.output = scan_address;
 225   1          new_keyh.field.input = bit_num;
 226   1          new_keyh.field.debounce_status = 1;
 227   1          new_keyl.field.state = 0;  /* Debounce has not counted out. */
 228   1          new_keyl.field.same = 0;   /* Key activity indication. */
 229   1      
 230   1          if (event == MAKE_EVENT)
 231   1          {   /* For MAKE key (key pressed). */
 232   2              new_keyl.field.trans = 0;
 233   2              new_keyl.field.count = Ext_Cb2.field.Break_Count; /* Shouldn't this be Make_Count? */
 234   2          }
 235   1          else
 236   1          {   /* For BREAK key (key released). */
 237   2              new_keyl.field.trans = 1;
 238   2              new_keyl.field.count = Ext_Cb2.field.Make_Count; /* Shouldn't this be Break_Count? */
 239   2          }
 240   1      }
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 5   

 241          
 242          /* ----------------------------------------------------------------------------
 243           * FUNCTION: find_paths
 244           *
 245           * Input:  DOWN_STATE  scan_address
 246           *         change_make_key
 247           *
 248           * Return: FALSE if no paths found, Otherwise returns TRUE.
 249           * ------------------------------------------------------------------------- */
 250          static FLAG find_paths(BYTE change_make_key, BYTE scan_address)
 251          {
 252   1          FLAG paths_found, done;
 253   1          BYTE paths, temp, bits;
 254   1          BYTE first_address;
 255   1      
 256   1          /* For the shift and bit test to work, "bits" MUST be unsigned.  (Right
 257   1             shifting an unsigned quantity fills vacated bits with zeros.  Right
 258   1             shifting a signed quantity will fill vacated bits with sign bits on some
 259   1             machines and zero bits on others.) */
 260   1          done = FALSE;
 261   1          paths_found = FALSE;
 262   1          first_address = scan_address;
 263   1      
 264   1          change_make_key &= ~(diode_key); /* Ignore diode key. */
 265   1          /* change_make_key = bKO_BITS. */
 266   1      
 267   1          if (change_make_key == 0) 
 268   1              {
 269   2              done = TRUE; /* paths_found == FALSE */
 270   2          }
 271   1      
 272   1          if (!done)
 273   1          {
 274   2              paths = bscan_matrix[scan_address] | change_make_key;
 275   2              paths &= ~(diode_key);  /* Ignore diode key. */
 276   2              /* paths = bKO_PATHS. */
 277   2              if (paths == 0) 
 278   2                      {
 279   3                  done = TRUE;  /* paths_found == FALSE */
 280   3              }
 281   2          }
 282   1      
 283   1          while (!done)
 284   1          {
 285   2              scan_address++;
 286   2      
 287   2              if (scan_address >= MAX_SCAN_LINES)     
 288   2              //if(scan_address >= STANDARD_SCAN_LINES)
 289   2                      {
 290   3                  scan_address = 0;   /* Wrap around */
 291   3              }
 292   2      
 293   2              if (scan_address == first_address) 
 294   2                      {
 295   3                  done = TRUE;        /* No scan lines left.  paths_found == FALSE */
 296   3              }
 297   2      
 298   2              if (!done)
 299   2              {   /* Check Path */
 300   3                  temp  = bscan_matrix[scan_address]; /* Any paths? */
 301   3                  temp &= ~(diode_key);               /* Ignore diode key */
 302   3      
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 6   

 303   3                  if (temp != 0) 
 304   3                              {    /* Paths found */
 305   4                      temp &= paths;  /* Do paths line up? */
 306   4                  }
 307   3      
 308   3                  if (temp != 0)
 309   3                  {   /* Paths line up */
 310   4                      if (change_make_key != temp)  /* Only 1 bit set? */
 311   4                      {   /* No, ghost exists. */
 312   5                          paths_found = TRUE;
 313   5                          done = TRUE;
 314   5                      }
 315   4      
 316   4                      if (!done)
 317   4                      {   /* The following checks if more than one bit is set to 1.
 318   5                             Because "bits" is unsigned, each shift moves the bit
 319   5                             under test out and a 0 bit in.  When the first 1 bit is
 320   5                             found, if "bits" == 0, this indicates that there is only
 321   5                             one bit set. */
 322   5                          bits = paths;  /* Only 1 bit set? */
 323   5                          temp = FALSE;
 324   5      
 325   5                          do
 326   5                          {
 327   6                              if (bits & 0x01) 
 328   6                                                      {
 329   7                                  temp = TRUE;
 330   7                              }
 331   6      
 332   6                              /* Shift bit out (and a zero bit in) to check next bit. */
 333   6                              bits = bits >> 1;
 334   6                          } while (temp == FALSE);
 335   5      
 336   5                          if (bits != 0)
 337   5                          {   /* No, more than 1 bit set. */
 338   6                              paths_found = TRUE;
 339   6                              done = TRUE;
 340   6                          }
 341   5                      } /* if (!done) */
 342   4                  } /* if (temp != 0) */
 343   3              } /* if (!done) */
 344   2          } /* while (!done) */
 345   1      
 346   1         return (paths_found);
 347   1      }
 348          
 349          /* ----------------------------------------------------------------------------
 350           * FUNCTION: debounce_key
 351           * ------------------------------------------------------------------------- */
 352          static void debounce_key(void)
 353          {                                                       
 354   1          scan.scan_line = new_keyh.field.output;     
 355   1          Write_Strobe(scan.scan_line); 
 356   1              CapDelay();     
 357   1          ITempB01 = Read_Scan_Lines(); 
 358   1          ITempB01 = ~ITempB01;            
 359   1      
 360   1          ITempB02 = Byte_Mask((BYTE) (new_keyh.field.input));        
 361   1          ITempB02 = ITempB02 & ITempB01;                                             
 362   1      
 363   1          if (ITempB02 != 0)
 364   1          {  
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 7   

 365   2              if (new_keyl.field.trans == 0) 
 366   2                      {
 367   3                  new_keyl.field.same = 1;    // last key detected as a MAKE,  same = 1.
 368   3              }
 369   2              else 
 370   2                      {
 371   3                  new_keyl.field.same = 0;    // last key detected as a BREAK, same = 0.
 372   3              }
 373   2          }
 374   1          else
 375   1          { 
 376   2              if (new_keyl.field.trans == 0) 
 377   2                      {
 378   3                  new_keyl.field.same = 0;    // last key detected as a MAKE,  same = 0. 
 379   3              }
 380   2              else 
 381   2                      {
 382   3                  new_keyl.field.same = 1;    // last key detected as a BREAK, same = 1. 
 383   3              }
 384   2          } 
 385   1      #if 0           // Dino 0201 change keyboard debounce time to 5ms
                  if (new_keyl.field.state == 0)
                  {  
                      if (new_keyl.field.count != 0)
                      {   
                          new_keyl.field.count--;
                      }
                      else
                      {
                          if (new_keyl.field.same == 0)
                          {   
                              new_keyh.byte = 0;      // Debounce failed, so claer all data
                              new_keyl.byte = 0;
                          }
                          else
                          {   
                              new_keyl.field.state = 1;
                          } 
                      }
                  }
                  else
              #endif          
 407   1          { 
 408   2              if (new_keyl.field.same == 0)
 409   2              {   
 410   3                  new_keyh.byte = 0;  // Debounce failed. 
 411   3                  new_keyl.byte = 0;
 412   3              }
 413   2              else
 414   2              { 
 415   3                      change_valid();         // Debounce OK 
 416   3              } 
 417   2          }
 418   1      }
 419          
 420          /* ----------------------------------------------------------------
 421           * FUNCTION: Read_Scan_Lines - Read KSI[7:0] of the scan matrix
 422           *
 423           * Return: Data from sense lines that are enabled.
 424           *         The lines that are disabled return 1s.
 425           *
 426           * C prototype: BYTE Read_Scan_Lines();
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 8   

 427           * ---------------------------------------------------------------- */
 428          BYTE Read_Scan_Lines(void)
 429          {
 430   1              return (KSI);                  
 431   1      }
 432          
 433          /* ---------------------------------------------------------------
 434           * FUNCTION: change_valid
 435           * --------------------------------------------------------------- */
 436          static void change_valid(void)
 437          {
 438   1          ITempB04 = Byte_Mask((BYTE) (new_keyh.field.input)); 
 439   1          ITempB03 = bscan_matrix[new_keyh.field.output]; 
 440   1          ITempB03 = ITempB03 ^ ITempB04;                         
 441   1          bscan_matrix[new_keyh.field.output] = ITempB03; 
 442   1      
 443   1              ITempB05 = BREAK_EVENT;                 // Ready for BREAK indication. 
 444   1          if ((ITempB04 & ITempB03) != 0)
 445   1          {                                                   
 446   2              ITempB05 = MAKE_EVENT;                                  
 447   2              typematic.byte = new_keyh.byte; // Set New Typematic Key.
 448   2              scan.TMscale = TM_SCALE;
 449   2              bTMcount = bTMdelay;
 450   2      
 451   2                      etkeytypematic.byte = 0x00;
 452   2          }
 453   1              
 454   1          Send_Scan2(new_keyh, ITempB05);
 455   1          new_keyh.byte = 0;
 456   1          new_keyl.byte = 0; 
 457   1      }
 458          
 459          /* ----------------------------------------------------------------------------
 460           * FUNCTION: check_tm - Handle typematic function.
 461           *
 462           * Input: Typematic key
 463           * ------------------------------------------------------------------------- */
 464          static void check_tm(union KEY key)
 465          {
 466   1              ITempB02 = FALSE;                                                                               
 467   1          ITempB01 = Byte_Mask((BYTE) (key.field.input)); 
 468   1          ITempB01 = ITempB01 & bscan_matrix[key.field.output];
 469   1      
 470   1          if (ITempB01 == 0)                  // Release Typematic key? 
 471   1          {   
 472   2              typematic.byte = 0;     // Clear Typematic. 
 473   2              ITempB02 = TRUE;
 474   2          }
 475   1      
 476   1          if (!ITempB02)
 477   1          {  
 478   2              scan.TMscale--;          // Count down Prescale.
 479   2              if (scan.TMscale != 0) 
 480   2                      {
 481   3                  ITempB02 = TRUE;
 482   3              }
 483   2          }
 484   1      
 485   1          if (!ITempB02)
 486   1          {
 487   2              scan.TMscale = TM_SCALE;// Reload prescale counter. 
 488   2              bTMcount--;             // Count down TMcount. 
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 9   

 489   2              if (bTMcount != 0) 
 490   2                      {
 491   3                  ITempB02 = TRUE;
 492   3              }
 493   2          }
 494   1      
 495   1          if (!ITempB02)
 496   1          {
 497   2              bTMcount = bTMrepeat;   // Reload TMcount. 
 498   2              Send_Scan2(key, REPEAT_EVENT);   
 499   2          }
 500   1      }
 501          
 502          /* ----------------------------------------------------------------
 503           * FUNCTION: Scan_Init - Initialize internal keyboard (scanner)
 504           * ---------------------------------------------------------------- */
 505          void Scan_Init(void)                                    // Lower all KSO lines for scan matrix
 506          {
 507   1              KSOL=0x00;  
 508   1              KSOH1=0x00;
 509   1              
 510   1              if(ExtendMatrix)                                // The function of extend keys
 511   1              {
 512   2                      KSOH2=0x00;
 513   2                      
 514   2                      Hook_SetGPIOScanPinCtrl();
 515   2                      Hook_SetGPIOScanPinL();
 516   2              }
 517   1      }
 518          
 519          /* ----------------------------------------------------------------
 520           * FUNCTION: Enable_Any_Key_Irq
 521           *
 522           * Setup for any key from scanner to generate an interrupt.
 523           *
 524           * Lower the "strobe" lines so that when any key is pressed at least one input
 525           * line will go low.  Any bits (out of the possible 16) that are not used for
 526           * the internal keyboard (scanner) are left alone.  This is done using
 527           * Config.Msk_Strobe_H and Config.Msk_Strobe_L.
 528           *
 529           * Then, if the internal keyboard (scanner) is enabled, allow the interrupt to
 530           * occur when a key is pressed on the scanner.
 531           * -------------------------------------------------------------- */
 532          void Enable_Any_Key_Irq(void)   // Lower all KSO lines for scan matrix
 533          {
 534   1              KSOL=0x00;             
 535   1              KSOH1=0x00;
 536   1              
 537   1              if (ExtendMatrix)
 538   1              {
 539   2                      KSOH2=0x00;
 540   2                      Hook_SetGPIOScanPinL();
 541   2              }       
 542   1              SET_MASK(IER1,Int_KB);      // enable KSI interrupt                                     
 543   1      }
 544          
 545          /* ----------------------------------------------------------------------------
 546           * FUNCTION:   Start_Scan_Transmission
 547           *
 548           * Lock out other devices so scanner can transmit data to Host, and start
 549           * Timer B with event "SEND_ENABLE".  When the "RESPONSE_TIME" has expired,
 550           * the Timer B interrupt handler will post a "SEND" service request to be
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 10  

 551           * dispatched by the main service loop.  At that time the data will be sent to
 552           * the Host via the "SEND" service handler.
 553           * ------------------------------------------------------------------------- */
 554          void Start_Scan_Transmission(void)
 555          {
 556   1          //Load_Timer_B();
 557   1          //Timer_B.fbit.SEND_ENABLE = 1;
 558   1          SetServiceSendFlag();
 559   1      }
 560          
 561          /* ----------------------------------------------------------------------------
 562           * FUNCTION:   Check_Scan_Transmission
 563           *
 564           * See if the scanner keyboard data transmission (to Host) should be allowed.
 565           *
 566           * Return: Transmission status indication.  TRUE if ok to transmit.
 567           * ------------------------------------------------------------------------- */
 568          FLAG Check_Scan_Transmission(void)
 569          {
 570   1          FLAG allow_transmission = FALSE;
 571   1      
 572   1          if ((Int_Var.Scan_Lock == 0) && (Flag.SCAN_INH == 0)) 
 573   1          {           /* Scanner transmission is locked and inhibited. */ 
 574   2          
 575   2              if (scan.kbf_head != scan.kbf_tail) 
 576   2                      {
 577   3                  allow_transmission = TRUE;  /* Allow transmission */
 578   3              }
 579   2          }    
 580   1      
 581   1          return (allow_transmission);
 582   1      }
 583          
 584          /* ----------------------------------------------------------------
 585           * FUNCTION: Get_Kbd_Type
 586           *
 587           * Returns the type of the internal keyboard.
 588           *
 589           * Returns: 0 = U.S. keyboard, 1 = Japanese keyboard.
 590           * -------------------------------------------------------------- */
 591          FLAG Get_Kbd_Type(void)
 592          {                                               // Check keyboard type here
 593   1                                                      // Returns: 0 = U.S. keyboard, 1 = Japanese keyboard.
 594   1              if(1)                           // check type here
 595   1              {
 596   2                      return(0);      // U.S. keyboard. 
 597   2              }
 598   1              else
 599   1              {
 600   2                      return(1);              // Japanese keyboard
 601   2              }
 602   1      }
 603          
 604          /* ----------------------------------------------------------------------------
 605           * FUNCTION: Lock_Scan
 606           *
 607           * Lock out the scanner via "Scan_Lock" and clear pending scanner "SEND"
 608           * events.
 609           * ------------------------------------------------------------------------- */
 610          void Lock_Scan(void)
 611          {
 612   1          Int_Var.Scan_Lock = 1;
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 11  

 613   1          //Timer_B.fbit.SEND_ENABLE = 0;
 614   1      }
 615          
 616          /* ----------------------------------------------------------------------------
 617           * FUNCTION: Init_Kbd - Scanner Keyboard Initialization.
 618           * ------------------------------------------------------------------------- */
 619          void Unlock_Scan(void) 
 620          {
 621   1              Int_Var.Scan_Lock = 0;
 622   1      }
 623          
 624          void CheckKSO1617Support(void)
 625          {
 626   1              ExtendScanPin = 0x00;
 627   1      
 628   1              if((KSO16CtrlReg&0xFB)==0x00)
 629   1              {
 630   2                      ExtendScanPin++;
 631   2              }
 632   1      
 633   1              if((KSO17CtrlReg&0xFB)==0x00)
 634   1              {
 635   2                      ExtendScanPin++;
 636   2              }
 637   1              
 638   1              if(ExtendScanPin!=0x00)
 639   1              {
 640   2                      ExtendMatrix = 1; 
 641   2              } 
 642   1              else
 643   1              {
 644   2                      ExtendMatrix = 0;
 645   2              }
 646   1      }
 647          
 648          /* ----------------------------------------------------------------------------
 649           * FUNCTION: Init_Kbd - Scanner Keyboard Initialization.
 650           * ------------------------------------------------------------------------- */
 651          void Init_Kbd(void)
 652          {
 653   1              CheckKSO1617Support();
 654   1      
 655   1              Scan_Init();  
 656   1      
 657   1              Hook_Setup_Scanner_Pntr();
 658   1          Setup_Diode_Key();
 659   1      
 660   1          new_keyh.byte = 0;
 661   1          new_keyl.byte = 0;
 662   1      
 663   1              ClearExtendKeys();      // for extend keys
 664   1      
 665   1          Clear_Fn_Keys();
 666   1          Clear_Key();        /* Clear key matrix/buffer */
 667   1          Clear_Typematic();
 668   1      
 669   1              Enable_Any_Key_Irq();
 670   1      
 671   1          FN_Key_Break = 0x00;        // Clear FN_Key_Break
 672   1          FN_Key_Break_HS = 0x00;
 673   1      
 674   1          ClearFnKeyBundledFalg();
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 12  

 675   1          
 676   1          #if KB_FnStickKey
                  FnStickKey = 0;
                  #endif
 679   1      }
 680          
 681          /* ----------------------------------------------------------------------------
 682           * FUNCTION:   Setup_Diode_Key
 683           * ------------------------------------------------------------------------- */
 684          void Setup_Diode_Key(void)
 685          {
 686   1              if(1)
 687   1              {   
 688   2              //if (Ext_Cb3_DISABLE_NKEY) { /* Simple matrix (NO diodes) */
 689   2              diode_key = 0x00;
 690   2          }
 691   1          else 
 692   1              {                      /* N-key (diodes in keyboard) */
 693   2              diode_key = 0xFF;
 694   2          }
 695   1      }
 696          
 697          
 698          /* ----------------------------------------------------------------------------
 699           * FUNCTION: Clear_Key - Clear local keyboard buffer and related variables.
 700           * ------------------------------------------------------------------------- */
 701          void Clear_Key(void)
 702          {
 703   1          BYTE i;
 704   1          //WORD msk_strobe;
 705   1      
 706   1          for(i = 0; i < MAX_SCAN_LINES; i++) // Clear scan matrix.
 707   1              {
 708   2              bscan_matrix[i] = 0;
 709   2          }
 710   1      
 711   1          for(i = 0; i < KBF_SIZE; i++)               // Clear key buffer.
 712   1              {
 713   2              bKEY_BUFF[i] = 0;
 714   2          }
 715   1      
 716   1          scan.kbf_head = 0;
 717   1          scan.kbf_tail = 0;
 718   1          typematic.byte = 0;
 719   1          scan.saf_make = 0;
 720   1          scan.saf_break = 0;
 721   1          scan.saf_keys = 0;
 722   1              scan.scan_line = 0;
 723   1      }
 724          
 725          
 726          /* ----------------------------------------------------------------------------
 727           * FUNCTION: Clear_Typematic - Set default typematic delay and clear type-matic action.
 728           * ------------------------------------------------------------------------- */
 729          void Clear_Typematic(void)
 730          {
 731   1          typematic.byte = 0;
 732   1          bTMdelay = TM_DELAY;
 733   1          bTMrepeat = TM_REPEAT;
 734   1      }
 735          
 736          /* ----------------------------------------------------------------------------
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 13  

 737           * FUNCTION: Set_Typematic - Set the typematic rate.
 738           *
 739           * Input: typematic rate
 740           *        Bit[4:0] Typematic repeat interval
 741           *        Bit[6:5] Delay time
 742           * ------------------------------------------------------------------------- */
 743          //const BYTE code repeat_tbl[] =
 744          //{
 745          //     3,  4,  4,  5,  5,  6,  6,  7,  7,  8,  9, 10, 11, 12, 13, 14,
 746          //    15, 16, 18, 20, 22, 24, 25, 27, 30, 33, 37, 41, 44, 48, 52, 55
 747          //};
 748          //const BYTE code delay_tbl[] = {27, 55, 83, 111};
 749          
 750          const BYTE code repeat_tbl[] =
 751          {
 752               3,  4,  4,  5,  5,  5,  6,  6,  7,  7,  8, 9, 10, 11, 11, 12,
 753              13, 15, 16, 18, 20, 21, 23, 25, 27, 30, 33, 37, 40, 43, 47, 50
 754          };
 755          const BYTE code delay_tbl[] = {25, 50, 75, 100};
 756          
 757          void Set_Typematic(WORD type_rate)
 758          {
 759   1          Save_Typematic = type_rate;   /* Save for suspend/resume. */
 760   1      
 761   1          /* Bit 4 - 0 typematic repeat interval index. */
 762   1          bTMrepeat = repeat_tbl[type_rate & 0x1F];
 763   1      
 764   1          /* Bit 6 - 5 delay time index. */
 765   1          bTMdelay = delay_tbl[(type_rate >> 5) & 0x03];
 766   1      }
 767          
 768          
 769          /* ----------------------------------------------------------------------------
 770           * FUNCTION: Handle_Scan - Service the local keyboard in response to a key press.
 771           * ------------------------------------------------------------------------- */
 772          void service_scan(void)
 773          {
 774   1              BYTE scan_activity;
 775   1      
 776   1          if (Timer_A.fbit.TMR_SCAN == 0)
 777   1          {
 778   2              Timer_A.fbit.TMR_SCAN = 1;      // Activate scan timer.
 779   2          }
 780   1              
 781   1              if(ExtendMatrix)                                // extend keys  
 782   1              {
 783   2                      scan_activity = scan_keys()|bScanExtendKeys();   
 784   2              }
 785   1              else 
 786   1              {
 787   2                      scan_activity = scan_keys();// Scan keyboard matrix one time.
 788   2              }
 789   1      
 790   1              if (scan_activity)                              // There is scan activity.
 791   1          {           
 792   2              ;
 793   2              }
 794   1          else                                                        // No scan activity 
 795   1          {   
 796   2              Timer_A.fbit.TMR_SCAN = 0;  // Disable the scan timer. 
 797   2              F_Service_KEY = 0;              // Clear any pending service request.  
 798   2              Enable_Any_Key_Irq();       // Enable Any Key interrupt.
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 14  

 799   2              FN_Key_Break = 0x00;        // Clear FN_Key_Break
 800   2              FN_Key_Break_HS = 0x00;
 801   2      
 802   2              ClearFnKeyBundledFalg();
 803   2              }
 804   1      
 805   1          if (Timer_B.fbit.SEND_ENABLE == 0)  // 1 = Device send request (Request already set)
 806   1          {
 807   2                      if (Check_Scan_Transmission())  // Data available
 808   2                      {   
 809   3                      Start_Scan_Transmission();      // Start new transmission
 810   3              }
 811   2          }
 812   1      }
 813          
 814          
 815          /*****************************************************************************/
 816          /********** SCANNER KEY BUFFER ROUTINES **************************************/
 817          /*****************************************************************************/
 818          
 819          /* ----------------------------------------------------------------------------
 820           * FUNCTION:   Get_Buffer
 821           *
 822           * Get data byte from keyboard buffer (if not empty) and update "scan.kbf_head"
 823           * with new index into keyboard buffer.
 824           *
 825           * Return: Data from buffer (WORD of all 1's if buffer is empty).
 826           * ------------------------------------------------------------------------- */
 827          //WORD Get_Buffer(void)
 828          BYTE Get_Buffer(void)
 829          {
 830   1          //WORD buffer_data;
 831   1          BYTE buffer_data;
 832   1      
 833   1          if (scan.kbf_head != scan.kbf_tail)
 834   1          {
 835   2              //buffer_data = (WORD) bKEY_BUFF[scan.kbf_head++];
 836   2                      buffer_data = bKEY_BUFF[scan.kbf_head++];
 837   2              if (scan.kbf_head >= KBF_SIZE) 
 838   2                      {
 839   3                  scan.kbf_head = 0;
 840   3              }
 841   2          }
 842   1          else
 843   1          {   /* Buffer is empty. */
 844   2              buffer_data = 0xFF;
 845   2          }
 846   1          return (buffer_data);
 847   1      }
 848          
 849          /* ----------------------------------------------------------------------------
 850           * FUNCTION:   Buffer_Mark - Mark local keyboard buffer tail.
 851           * ------------------------------------------------------------------------- */
 852          void Buffer_Mark(void)
 853          {
 854   1          scan.kbf_mark = scan.kbf_tail;   /* Copy scan.kbf_tail to scan.kbf_mark. */
 855   1      }
 856          
 857          /* ----------------------------------------------------------------------------
 858           * FUNCTION:   Buffer_Key
 859           *
 860           * Input:  Row/Column (0iii,oooo) to put in buffer.
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 15  

 861           * Return: TRUE operation successful, FALSE unsuccessful.
 862           * ------------------------------------------------------------------------- */
 863          FLAG Buffer_Key(BYTE row_column)
 864          {
 865   1          FLAG ready = TRUE;  /* Ready for successful operation */
 866   1      
 867   1          bKEY_BUFF[scan.kbf_tail] = row_column;  /* Store Data to Buffer Tail */
 868   1          scan.kbf_tail++;                        /* Increment Buffer Tail (pointer) */
 869   1      
 870   1          if (scan.kbf_tail >= KBF_SIZE) 
 871   1              {
 872   2              scan.kbf_tail = 0;  /* Wrap pointer if too large. */
 873   2          }
 874   1      
 875   1          /* Check Overflow */
 876   1          if (scan.kbf_tail == scan.kbf_head)
 877   1          {   /* Overflow */
 878   2              scan.kbf_tail = scan.kbf_mark;  /* Restore buffer marker. */
 879   2              bKEY_BUFF[scan.kbf_tail] = 0;   /* Set OverFlow Mark. */
 880   2              ready = FALSE;                  /* Overflow Indication !!! */
 881   2          }
 882   1      
 883   1          return (ready);
 884   1      }
 885          
 886          
 887          /* ----------------------------------------------------------------------------
 888           * FUNCTION:   Buffer_String
 889           *
 890           * Places a string in the local keyboard buffer (without a terminating NULL).
 891           * Call Buffer_Key to place data in key buffer.
 892           *
 893           * Input:  Pointer to null terminated string.
 894           * Return: 0x80 if buffer overflow error, else 0.
 895           * ------------------------------------------------------------------------- */
 896          BYTE Buffer_String(const BYTE *pntr)
 897          {
 898   1          register BYTE error = 0;
 899   1      
 900   1          while ((*pntr != 0) && (error == 0))
 901   1          {
 902   2              if (Buffer_Key(*pntr++) == 0) {
 903   3                  error = 0x80;   /* Indicate Overflow */
 904   3              }
 905   2          }
 906   1      
 907   1          return (error);
 908   1      }
 909          
 910          //*****************************************************************
 911          // The functions of extend keys
 912          //*****************************************************************
 913          //-----------------------------------------------------------------
 914          // The function of Scaning extend keys
 915          //-----------------------------------------------------------------
 916          BYTE bScanExtendKeys(void)
 917          {
 918   1              ITempB06 = FALSE;
 919   1              extendscan.saf_break = 0;
 920   1              extendscan.saf_make= 0;
 921   1              extendscan.saf_keys= 0;
 922   1      
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 16  

 923   1              if (etkeytypematic.byte) 
 924   1              {
 925   2              CheckEtKeystm(etkeytypematic);  // Check typematic. 
 926   2              }
 927   1      
 928   1              if (new_extendkey.byte)                 
 929   1              {                                                               // Yes, bounding.
 930   2              extendscan.saf_make = 1;  
 931   2              DebounceExtendkey();
 932   2              ITempB06 = TRUE;
 933   2              }
 934   1      
 935   1              if(ITempB06 == FALSE)
 936   1              {
 937   2              for (ITempB01=0;ITempB01<ExtendScanPin;ITempB01++)
 938   2              {
 939   3                              SetExtendScanLines(ITempB01);
 940   3                              ITempB02 = KSI;
 941   3                              ITempB02 = (~ITempB02)^bscan_matrix[ITempB01+STANDARD_SCAN_LINES];
 942   3                  if (ITempB02 != 0) 
 943   3                      {
 944   4                                      CheckExtendKeys(ITempB02,(ITempB01+STANDARD_SCAN_LINES));
 945   4                      }
 946   3      
 947   3                  if (bscan_matrix[ITempB01+STANDARD_SCAN_LINES]) 
 948   3                      {                                                               // Here, if current still active.
 949   4                      extendscan.saf_keys = 1;        // Set keys active bits. Check all key release.
 950   4                  }   
 951   3                  
 952   3                  KSOH2 = 0xFF;
 953   3                          Hook_SetGPIOScanPinH();
 954   3              }
 955   2              }
 956   1      
 957   1              if (extendstatus.field.ghost == 1)
 958   1              {  
 959   2              extendstatus.field.ghost = 0;   // Ghost flag is set.
 960   2              ITempB01 = extendstatus.byte & 7;
 961   2                      if (ITempB01 == 0)
 962   2              {  
 963   3                      ITempB01 = Byte_Mask((BYTE)(new_extendkey.field.input));
 964   3                      ITempB01 = ITempB01 & diode_key; 
 965   3                      }
 966   2              if (ITempB01 == 0)
 967   2              {   
 968   3                      new_extendkey.byte = 0;         // Clear new key. 
 969   3                      extendstatus.byte = 0;
 970   3              }
 971   2              } 
 972   1              
 973   1              return((BYTE) (extendscan.saf_make + extendscan.saf_break + extendscan.saf_keys));
 974   1      }
 975          
 976          //-----------------------------------------------------------------
 977          // The function of Setting extend scan lines
 978          //-----------------------------------------------------------------
 979          void SetExtendScanLines(BYTE scan_line)
 980          {
 981   1              if(scan_line<0x02)
 982   1              {
 983   2                      KSOL = 0xFF;
 984   2                      KSOH1 = 0xFF;
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 17  

 985   2                      KSOH2 = ~(0x01<<scan_line);
 986   2                      Hook_SetGPIOScanPinH();
 987   2              }
 988   1              else 
 989   1              {
 990   2                      KSOL = 0xFF;
 991   2                      KSOH1 = 0xFF;
 992   2                      KSOH2 = 0xFF;
 993   2                      Hook_SetGPIOScanPinL();
 994   2              }
 995   1          CapDelay();
 996   1      }
 997          
 998          //-----------------------------------------------------------------
 999          // The function of Setting extend scan lines
1000          //-----------------------------------------------------------------
1001          void CheckExtendKeys(KSI_bit_num, scan_address)
1002          {
1003   1          BYTE flag;
1004   1          BYTE change_make_key;
1005   1             
1006   1              flag = FALSE;                           
1007   1              if (extendstatus.field.ghost == 1)
1008   1              {
1009   2              flag = TRUE;
1010   2              }
1011   1              else
1012   1              {                                                       // Find 0 -> 1 's.
1013   2                      change_make_key = KSI_bit_num & ~bscan_matrix[scan_address];
1014   2              if (change_make_key == 0) 
1015   2                      {
1016   3                      flag = FALSE;
1017   3              }
1018   2              else if (find_paths(change_make_key, scan_address)) 
1019   2                      {
1020   3                      flag = TRUE;                            // TRUE if ghost keys.
1021   3              }
1022   2              }
1023   1      
1024   1              if (flag)
1025   1              {                                                               // Ghost exists. 
1026   2              extendstatus.field.ghost = 1;   // Set ghost flag.
1027   2              KSI_bit_num &= bscan_matrix[scan_address] | diode_key;
1028   2              }
1029   1      
1030   1              ITempB03 = 0x00;
1031   1          while (KSI_bit_num != 0)
1032   1          {   
1033   2              if (KSI_bit_num & 0x01)         
1034   2                      {
1035   3                      if (bscan_matrix[scan_address] & Byte_Mask(ITempB03))
1036   3                              {  
1037   4                              if (extendscan.saf_break == 0) 
1038   4                                      {
1039   5                              extendscan.saf_break = 1;
1040   5                                              ExtendKeyDebounce(ITempB03, scan_address, BREAK_EVENT);
1041   5                              }
1042   4                      }
1043   3                      else
1044   3                      {
1045   4                              if (extendscan.saf_make == 0) 
1046   4                                      {
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 18  

1047   5                              extendscan.saf_make = 1;
1048   5                                              ExtendKeyDebounce(ITempB03, scan_address, MAKE_EVENT);
1049   5                              }
1050   4                      } 
1051   3              }
1052   2              ITempB03++;
1053   2              KSI_bit_num = KSI_bit_num >> 1; /* Shift bit out (and a zero bit in) to check next bit. */
1054   2          }
1055   1      }
1056          
1057          //-----------------------------------------------------------------
1058          // The function of extend keys debounce
1059          //-----------------------------------------------------------------
1060          void ExtendKeyDebounce(BYTE KSI_bit_num, BYTE scan_address, BYTE event)
1061          {
1062   1          new_extendkey.field.output = scan_address-STANDARD_SCAN_LINES;
1063   1          new_extendkey.field.input = KSI_bit_num;
1064   1          new_extendkey.field.debounce_status = 1;
1065   1          extendstatus.field.state = 0;  // Debounce has not counted out. */
1066   1          extendstatus.field.same = 0;   // Key activity indication. */
1067   1      
1068   1          if (event == MAKE_EVENT)
1069   1          { 
1070   2              extendstatus.field.trans = 0;
1071   2              extendstatus.field.count = 1;//Ext_Cb2.field.Break_Count; 
1072   2          }
1073   1          else
1074   1          {  
1075   2              extendstatus.field.trans = 1;
1076   2              extendstatus.field.count = 1;//Ext_Cb2.field.Make_Count; 
1077   2          }
1078   1      }
1079          
1080          
1081          void DebounceExtendkey(void)
1082          {
1083   1              SetExtendScanLines(new_extendkey.field.output);
1084   1              ITempB04 = Read_Scan_Lines();
1085   1              ITempB04 = ~ITempB04;
1086   1              ITempB05 = Byte_Mask((BYTE)(new_extendkey.field.input)); 
1087   1              ITempB05 = ITempB05 & ITempB04;
1088   1      
1089   1              if (ITempB05 != 0)
1090   1          {  
1091   2              if (extendstatus.field.trans == 0)      // key make
1092   2                      {
1093   3                  extendstatus.field.same = 1;        // last key detected as a MAKE, same = 1.
1094   3              }
1095   2              else 
1096   2                      {
1097   3                  extendstatus.field.same = 0;    // last key detected as a BREAK, same = 0.
1098   3              }
1099   2          }
1100   1          else
1101   1          { 
1102   2              if (extendstatus.field.trans == 0) 
1103   2                      {
1104   3                  extendstatus.field.same = 0;    // last key detected as a MAKE, same = 0. 
1105   3              }
1106   2              else 
1107   2                      {
1108   3                  extendstatus.field.same = 1;    // last key detected as a BREAK, same = 1. 
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 19  

1109   3              }
1110   2          } 
1111   1      
1112   1          if (extendstatus.field.state == 0)  // 1 means debounce counted out.
1113   1          {  
1114   2              if (extendstatus.field.count != 0)
1115   2              {  
1116   3                  extendstatus.field.count--;
1117   3              }
1118   2              else
1119   2              {
1120   3                  if (extendstatus.field.same == 0)
1121   3                  {   
1122   4                      new_extendkey.byte = 0; // Debounce failed, so claer all data
1123   4                      extendstatus.byte = 0;
1124   4                  }
1125   3                  else
1126   3                  {  
1127   4                      extendstatus.field.state = 1;
1128   4                  } 
1129   3              } 
1130   2          }
1131   1          else
1132   1          { 
1133   2              if (extendstatus.field.same == 0)
1134   2              {   
1135   3                  new_extendkey.byte = 0;     /* Debounce failed. */
1136   3                  extendstatus.byte = 0;
1137   3              }
1138   2              else
1139   2              {   
1140   3                      CheckExtendKeyValid();
1141   3              } 
1142   2          }
1143   1      }
1144          
1145          
1146          //-----------------------------------------------------------------
1147          // The function of checking extend key valid
1148          //-----------------------------------------------------------------
1149          void CheckExtendKeyValid(void)
1150          {
1151   1          ITempB02 = Byte_Mask((BYTE) (new_extendkey.field.input)); 
1152   1          ITempB01 = bscan_matrix[(new_extendkey.field.output + STANDARD_SCAN_LINES)];
1153   1          ITempB01 = ITempB01 ^ ITempB02;                        
1154   1          bscan_matrix[(new_extendkey.field.output + STANDARD_SCAN_LINES)] = ITempB01; 
1155   1      
1156   1              ITempB03 = BREAK_EVENT;                       
1157   1          if ((ITempB02 & ITempB01) != 0)
1158   1          {                                                   
1159   2              ITempB03 = MAKE_EVENT;                                                          
1160   2              etkeytypematic.byte = new_extendkey.byte;
1161   2              extendscan.TMscale = TM_SCALE;
1162   2              bTMcount = bTMdelay;
1163   2                      
1164   2                      typematic.byte = 0x00;
1165   2          }
1166   1              
1167   1          Send_EtScan2(new_extendkey, ITempB03);
1168   1          new_extendkey.byte = 0;
1169   1          extendstatus.byte = 0;
1170   1      }
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 20  

1171          
1172          //-----------------------------------------------------------------
1173          // The function of
1174          //-----------------------------------------------------------------
1175          void Send_EtScan2(union KEY key, BYTE event)
1176          {       
1177   1              if(IS_MASK_SET(UtilityFlag,KBDebug))
1178   1              {
1179   2                      if(KeyScanACK==KU_ACK_Start)
1180   2                      {
1181   3                              if(event==MAKE_EVENT)
1182   3                              {
1183   4                                      KeyScanKSI = key.field.input;
1184   4                                      KeyScanKSO = key.field.output;
1185   4                                      KeyScanACK = KU_ACK_FullKeyboard;
1186   4                              }
1187   3                      }
1188   2              }
1189   1              else
1190   1              {
1191   2              ITempB02 = (key.field.input * 3) + key.field.output; 
1192   2                      ITempB01 = *(Extendkey_Table_Pntr + ITempB02);
1193   2      
1194   2                      Et_Hook_keyboard(key.field.input, key.field.output);
1195   2              Send_Key(ITempB01, event);
1196   2              }
1197   1      }
1198          
1199          //-----------------------------------------------------------------
1200          // The function of clearing extend keys
1201          //-----------------------------------------------------------------
1202          void ClearExtendKeys(void)
1203          {
1204   1              new_extendkey.byte = 0;         
1205   1              extendstatus.byte = 0;
1206   1              etkeytypematic.byte = 0;
1207   1      }
1208          
1209          //-----------------------------------------------------------------
1210          // The function of checking extend keys Typematic
1211          //-----------------------------------------------------------------
1212          void CheckEtKeystm(union KEY key)
1213          {
1214   1              ITempB02 = FALSE;
1215   1          ITempB01 = Byte_Mask((BYTE) (key.field.input)); 
1216   1          ITempB01 = ITempB01 & bscan_matrix[key.field.output+STANDARD_SCAN_LINES];
1217   1      
1218   1          if (ITempB01 == 0) 
1219   1          {
1220   2              etkeytypematic.byte = 0;
1221   2              ITempB02 = TRUE;
1222   2          }
1223   1      
1224   1          if (!ITempB02)
1225   1          {
1226   2              extendscan.TMscale--;
1227   2              if (extendscan.TMscale != 0) 
1228   2                      {
1229   3                  ITempB02 = TRUE;
1230   3              }
1231   2          }
1232   1      
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 21  

1233   1          if (!ITempB02)
1234   1          {
1235   2              extendscan.TMscale = TM_SCALE;
1236   2              bTMcount--;            
1237   2              if (bTMcount != 0) 
1238   2                      {
1239   3                  ITempB02 = TRUE;
1240   3              }
1241   2          }
1242   1      
1243   1          if (!ITempB02)
1244   1          {
1245   2              bTMcount = bTMrepeat;   
1246   2              Send_EtScan2(key,REPEAT_EVENT);  
1247   2          }
1248   1      }
1249          
1250          //*******************************************************
1251          //*******************************************************
1252          //*******************************************************
1253          #else   // Hardware scan keyboard
              //*******************************************************
              //*******************************************************
              //*******************************************************
              
              /* ----------------------------------------------------------------------------
               * FUNCTION:   Get_Buffer
               *
               * Get data byte from keyboard buffer (if not empty) and update "scan.kbf_head"
               * with new index into keyboard buffer.
               *
               * Return: Data from buffer (WORD of all 1's if buffer is empty).
               * ------------------------------------------------------------------------- */
              BYTE Get_Buffer(void)
              {
                  BYTE buffer_data;
              
                  if (scan.kbf_head != scan.kbf_tail)
                  {
                              buffer_data = bKEY_BUFF[scan.kbf_head++];
                      if (scan.kbf_head >= KBF_SIZE) 
                              {
                          scan.kbf_head = 0;
                      }
                  }
                  else
                  {   /* Buffer is empty. */
                      buffer_data = 0xFF;
                  }
                  return (buffer_data);
              }
              
              /* ----------------------------------------------------------------------------
               * FUNCTION:   Buffer_Mark - Mark local keyboard buffer tail.
               * ------------------------------------------------------------------------- */
              void Buffer_Mark(void)
              {
                  scan.kbf_mark = scan.kbf_tail;   /* Copy scan.kbf_tail to scan.kbf_mark. */
              }
              
              /* ----------------------------------------------------------------------------
               * FUNCTION:   Buffer_Key
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 22  

               *
               * Input:  Row/Column (0iii,oooo) to put in buffer.
               * Return: TRUE operation successful, FALSE unsuccessful.
               * ------------------------------------------------------------------------- */
              FLAG Buffer_Key(BYTE row_column)
              {
                  FLAG ready = TRUE;  /* Ready for successful operation */
              
                  bKEY_BUFF[scan.kbf_tail] = row_column;  /* Store Data to Buffer Tail */
                  scan.kbf_tail++;                        /* Increment Buffer Tail (pointer) */
              
                  if (scan.kbf_tail >= KBF_SIZE) 
                      {
                      scan.kbf_tail = 0;  /* Wrap pointer if too large. */
                  }
              
                  /* Check Overflow */
                  if (scan.kbf_tail == scan.kbf_head)
                  {   /* Overflow */
                      scan.kbf_tail = scan.kbf_mark;  /* Restore buffer marker. */
                      bKEY_BUFF[scan.kbf_tail] = 0;   /* Set OverFlow Mark. */
                      ready = FALSE;                  /* Overflow Indication !!! */
                  }
              
                  return (ready);
              }
              
              /* ----------------------------------------------------------------------------
               * FUNCTION:   Buffer_String
               *
               * Places a string in the local keyboard buffer (without a terminating NULL).
               * Call Buffer_Key to place data in key buffer.
               *
               * Input:  Pointer to null terminated string.
               * Return: 0x80 if buffer overflow error, else 0.
               * ------------------------------------------------------------------------- */
              BYTE Buffer_String(const BYTE *pntr)
              {
                  register BYTE error = 0;
              
                  while ((*pntr != 0) && (error == 0))
                  {
                      if (Buffer_Key(*pntr++) == 0) {
                          error = 0x80;   /* Indicate Overflow */
                      }
                  }
              
                  return (error);
              }
              
              /* ----------------------------------------------------------------
               * FUNCTION: Get_Kbd_Type
               *
               * Returns the type of the internal keyboard.
               *
               * Returns: 0 = U.S. keyboard, 1 = Japanese keyboard.
               * -------------------------------------------------------------- */
              FLAG Get_Kbd_Type(void)
              {                                               // Check keyboard type here
                                                              // Returns: 0 = U.S. keyboard, 1 = Japanese keyboard.
                      if(1)                           // check type here
                      {
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 23  

                              return(0);      // U.S. keyboard. 
                      }
                      else
                      {
                              return(1);              // Japanese keyboard
                      }
              }
              
              /* ----------------------------------------------------------------------------
               * FUNCTION: find_paths
               *
               * Input:  DOWN_STATE  scan_address
               *         change_make_key
               *
               * Return: FALSE if no paths found, Otherwise returns TRUE.
               * ------------------------------------------------------------------------- */
              static FLAG find_paths(BYTE change_make_key, BYTE scan_address)
              {
                  FLAG paths_found, done;
                  BYTE paths, temp, bits;
                  BYTE first_address;
              
                  /* For the shift and bit test to work, "bits" MUST be unsigned.  (Right
                     shifting an unsigned quantity fills vacated bits with zeros.  Right
                     shifting a signed quantity will fill vacated bits with sign bits on some
                     machines and zero bits on others.) */
                  done = FALSE;
                  paths_found = FALSE;
                  first_address = scan_address;
              
                  //change_make_key &= ~(diode_key); /* Ignore diode key. */
                  /* change_make_key = bKO_BITS. */
              
                  if (change_make_key == 0) 
                      {
                      done = TRUE; /* paths_found == FALSE */
                  }
              
                  if (!done)
                  {
                      paths = bscan_matrix[scan_address] | change_make_key;
                      //paths &= ~(diode_key);  /* Ignore diode key. */
                      /* paths = bKO_PATHS. */
                      if (paths == 0) 
                              {
                          done = TRUE;  /* paths_found == FALSE */
                      }
                  }
              
                  while (!done)
                  {
                      scan_address++;
              
                      if (scan_address >= 18)         
                      //if(scan_address >= STANDARD_SCAN_LINES)
                              {
                          scan_address = 0;   /* Wrap around */
                      }
              
                      if (scan_address == first_address) 
                              {
                          done = TRUE;        /* No scan lines left.  paths_found == FALSE */
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 24  

                      }
              
                      if (!done)
                      {   /* Check Path */
                          temp  = bscan_matrix[scan_address]; /* Any paths? */
                          //temp &= ~(diode_key);               /* Ignore diode key */
              
                          if (temp != 0) 
                                      {    /* Paths found */
                              temp &= paths;  /* Do paths line up? */
                          }
              
                          if (temp != 0)
                          {   /* Paths line up */
                              if (change_make_key != temp)  /* Only 1 bit set? */
                              {   /* No, ghost exists. */
                                  paths_found = TRUE;
                                  done = TRUE;
                              }
              
                              if (!done)
                              {   /* The following checks if more than one bit is set to 1.
                                     Because "bits" is unsigned, each shift moves the bit
                                     under test out and a 0 bit in.  When the first 1 bit is
                                     found, if "bits" == 0, this indicates that there is only
                                     one bit set. */
                                  bits = paths;  /* Only 1 bit set? */
                                  temp = FALSE;
              
                                  do
                                  {
                                      if (bits & 0x01) 
                                                              {
                                          temp = TRUE;
                                      }
              
                                      /* Shift bit out (and a zero bit in) to check next bit. */
                                      bits = bits >> 1;
                                  } while (temp == FALSE);
              
                                  if (bits != 0)
                                  {   /* No, more than 1 bit set. */
                                      paths_found = TRUE;
                                      done = TRUE;
                                  }
                              } /* if (!done) */
                          } /* if (temp != 0) */
                      } /* if (!done) */
                  } /* while (!done) */
              
                 return (paths_found);
              }
              
              /* ----------------------------------------------------------------------------
               * FUNCTION: Handle_Scan - Service the local keyboard in response to a key press.
               * ------------------------------------------------------------------------- */
              void service_scan(void)
              {
                  BYTE kso_index, ksi_index;
                  BYTE ksitemp;
                  BYTE extend_key;
                  ECReg *SDRPointer;
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 25  

              
                  //-----------------------------------------------------
                  // All key is pressed
                  //
                  if (Timer_A.fbit.TMR_SCAN == 0)
                  {
                      Timer_A.fbit.TMR_SCAN = 1;      // Activate scan timer.
                  }
              
                  //-----------------------------------------------------
                  // Pre-clear variables
                  //
                  scan.saf_keys = 0;
                  ksitemp = 0x00;
                  SDRPointer = &KSO0LSDR;
              
                  //-----------------------------------------------------
                  // Scan KSO0 ~ 15, 16, or 17
                  //
                  for(kso_index=0x00; kso_index<(16+ExtendScanPin); kso_index++)
                  {
                      ksitemp = ~(SDRPointer[kso_index]);                     // Read KSI and inverse
                      ksitemp = ksitemp ^ bscan_matrix[kso_index];
                      
                      if(ksitemp!=0x00)                                       // Status change (make-->brak, or break-->
             -make)
                      {
                          if(kso_index>15)                                    // KSO16, KSO17
                          {
                              KB_HW_ExtendKeyIndex=0x01;
                          }
                          else                                                // KSO0 ~ KSO15
                          {
                              KB_HW_ExtendKeyIndex=0x00;
                          }
              
                          //-----------------------------------------------------
                          // Check KSI0 ~ 7
                          //
                          for(ksi_index=0x00; ksi_index<8; ksi_index++)
                          {
                              if(IS_MASK_SET(ksitemp, BIT(ksi_index)))
                              {
                                  if(KB_HW_ExtendKeyIndex==0x01)              // KSO16, KSO17
                                  {
                                      new_keyh.field.output = (kso_index-16); // Save KSO for type union KEY
                                  }
                                  else                                        // KSO0 ~ KSO15
                                  {
                                      new_keyh.field.output = kso_index;      // Save KSO for type union KEY
                                  }
                                  new_keyh.field.input = ksi_index;           // Save KSI for type union KEY
               
                                  if(IS_MASK_CLEAR(bscan_matrix[kso_index], BIT(ksi_index)))  // Make
                                  {
                                      if(find_paths(ksitemp, kso_index)==FALSE)   // No ghost key 
                                      {
                                          Send_Scan2(new_keyh, MAKE_EVENT);   // Key make         
                                          typematic.byte = new_keyh.byte;     // Set typematic key
                                          scan.TMscale = TM_SCALE;            // Repeat time
                                          bTMcount = bTMdelay;                // Delay time
              
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 26  

                                          if(KB_HW_ExtendKeyIndex==0x01)      // KSO16, KSO17
                                          {
                                              KB_HW_ExtendKeyTypematic=0x01;  // Set key typematic of KSO16, KSO17 
                                          }
                                          else
                                          {
                                              KB_HW_ExtendKeyTypematic=0x00;  // Set key typematic of KSO0 ~ KSO15
                                          }
                                          SET_MASK(bscan_matrix[kso_index], BIT(ksi_index));
                                      }
                                      else                                    // ghost key found
                                      {
                                          typematic.byte = 0;                 // Clear Typematic. 
                                      }
                                  }
                                  else                                        // Break
                                  {
                                      Send_Scan2(new_keyh, BREAK_EVENT);      // Key break;
                                      CLEAR_MASK(bscan_matrix[kso_index], BIT(ksi_index));
                                  }
                              }
                          }
                      }
                      
                      //-----------------------------------------------------
                      // Any key still active.
                      //
                      if(bscan_matrix[kso_index]) 
                      {                                           // Here, if current still active. 
                          scan.saf_keys = 1;  // Set keys active bits. Check all key release. 
                      }  
                  }
              
                  //-----------------------------------------------------
                  // All key break
                  //
                  if((scan.saf_keys)==0x00)       // all key break
                  {
                      Clear_AllKeysBreak();
                  }
              
                  //-----------------------------------------------------
                  // Start sending keyboard data
                  //
                      if (scan.kbf_head != scan.kbf_tail)
                      {
                      F_Service_SEND = 1;         // Post service request
                      SetServiceSendFlag();
                      }
              
                  //-----------------------------------------------------
                  // Write to clear data valid bit and enabling interrupt 
                  //
                  SET_MASK(SDSR, SDV);            // Scan data valid W/C
                  SET_MASK(IER10, BIT4);          // Enable interrupt 
              }
              
              /* ----------------------------------------------------------------------------
               * FUNCTION: Init_Kbd - Scanner Keyboard Initialization.
               * ------------------------------------------------------------------------- */
              void Unlock_Scan(void) 
              {
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 27  

                      Int_Var.Scan_Lock = 0;
              }
              
              /* ----------------------------------------------------------------------------
               * FUNCTION: Lock_Scan
               *
               * Lock out the scanner via "Scan_Lock" and clear pending scanner "SEND"
               * events.
               * ------------------------------------------------------------------------- */
              void Lock_Scan(void)
              {
                  Int_Var.Scan_Lock = 1;
                  //Timer_B.fbit.SEND_ENABLE = 0;
              }
              
              /* ----------------------------------------------------------------------------
               * FUNCTION: Set_Typematic - Set the typematic rate.
               *
               * Input: typematic rate
               *        Bit[4:0] Typematic repeat interval
               *        Bit[6:5] Delay time
               * ------------------------------------------------------------------------- */
              const BYTE code repeat_tbl[] =
              {
                   3,  4,  4,  5,  5,  5,  6,  6,  7,  7,  8, 9, 10, 11, 11, 12,
                  13, 15, 16, 18, 20, 21, 23, 25, 27, 30, 33, 37, 40, 43, 47, 50
              };
              const BYTE code delay_tbl[] = {25, 50, 75, 100};
              
              void Set_Typematic(WORD type_rate)
              {
                  Save_Typematic = type_rate;   /* Save for suspend/resume. */
              
                  /* Bit 4 - 0 typematic repeat interval index. */
                  bTMrepeat = repeat_tbl[type_rate & 0x1F];
              
                  /* Bit 6 - 5 delay time index. */
                  bTMdelay = delay_tbl[(type_rate >> 5) & 0x03];
              }
              
              /* ----------------------------------------------------------------------------
               * FUNCTION: Clear_Key - Clear local keyboard buffer and related variables.
               * ------------------------------------------------------------------------- */
              void Clear_Key(void)
              {
                  BYTE i;
              
                  for(i = 0; i < MAX_SCAN_LINES; i++) // Clear scan matrix.
                      {
                      bscan_matrix[i] = 0;
                  }
              
                  for(i = 0; i < KBF_SIZE; i++)   // Clear key buffer.
                      {
                      bKEY_BUFF[i] = 0;
                  }
              
                  scan.kbf_head = 0;              // Clear keyboard buffer head
                  scan.kbf_tail = 0;              // Clear keyboard buffer tail
                  scan.saf_keys = 0;              // Clear Scan activity flag - keys active.
                  new_keyh.byte = 0;              // Clear KSO KSI
              
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 28  

                  Clear_AllKeysBreak();
                  
                  #if KB_FnStickKey
                  FnStickKey = 0;
                  #endif
              }
              
              /* ----------------------------------------------------------------------------
               * FUNCTION: Clear_Typematic - Set default typematic delay and clear type-matic action.
               * ------------------------------------------------------------------------- */
              void Clear_Typematic(void)
              {
                  typematic.byte = 0;
                  bTMdelay = TM_DELAY;
                  bTMrepeat = TM_REPEAT;
              }
              
              /* ----------------------------------------------------------------------------
               * FUNCTION: Init_Kbd - Scanner Keyboard Initialization.
               * ------------------------------------------------------------------------- */
              void Init_Kbd(void)
              {
                      CheckKSO1617Support();      // Check KSO16 and KSO17
                      Hook_Setup_Scanner_Pntr();  // to define the possible scanner tables
                  Clear_Key();                // Clear key matrix/buffer
                  Clear_Typematic();          // Clear Typematic 
                      Enable_Any_Key_Irq();       // Enable any key interrupt (HW mode)
              }
              
              //----------------------------------------------------------------------------
              //
              //----------------------------------------------------------------------------
              void CheckKSO1617Support(void)
              {
                      ExtendScanPin = 0x00;
              
                      if((KSO16CtrlReg&0xFB)==0x00)
                      {
                              ExtendScanPin++;
                      }
              
                      if((KSO17CtrlReg&0xFB)==0x00)
                      {
                              ExtendScanPin++;
                      }
              
                  if(ExtendScanPin>2)
                  {
                      ExtendScanPin=2;
                  }
              
                  Scan_Init();                // Initialize internal keyboard (HW scanner)
              }
              
              /* ----------------------------------------------------------------
               * FUNCTION: Scan_Init - Initialize internal keyboard (scanner)
               * ---------------------------------------------------------------- */
              void Scan_Init(void)
              {
                  SDC1R = SDEN+INTSDVEN+SLS_03_Round;     // Scan data enable, interrupt from scan data valid enable, 3 
             -round
              
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 29  

                  if(ExtendScanPin==0x02)                 // 18 x 8
                  {
                      SDC2R = KSOPCS1+WKSOHDLY_55us;      // 18 x 8, Wait KSO high delay 55us
                  }
                  else if(ExtendScanPin==0x01)            // 17 x 8
                  {
                      SDC2R = KSOPCS0+WKSOHDLY_55us;      // 17 x 8, Wait KSO high delay 55us
                  }
                  else                                    // 16 x 8
                  {
                      SDC2R = WKSOHDLY_55us;              // 16 x 8, Wait KSO high delay 55us
                  }
                  
                  SDC3R = WKSOLDLY_29us+SDLYBR_00ms;      // Wait KSO low delay 29us, spacing delay between rounds 0ms.
              }
              
              /* ----------------------------------------------------------------
               * FUNCTION: Enable_Any_Key_Irq
               *
               * Setup for any key from scanner to generate an interrupt.
               *
               * Lower the "strobe" lines so that when any key is pressed at least one input
               * line will go low.  Any bits (out of the possible 16) that are not used for
               * the internal keyboard (scanner) are left alone.  This is done using
               * Config.Msk_Strobe_H and Config.Msk_Strobe_L.
               *
               * Then, if the internal keyboard (scanner) is enabled, allow the interrupt to
               * occur when a key is pressed on the scanner.
               * -------------------------------------------------------------- */
              void Enable_Any_Key_Irq(void)
              {
                      ISR10 = BIT4;
                  SET_MASK(IER10, BIT4);  
              }
              
              /* ----------------------------------------------------------------------------
               * FUNCTION: check_tm - Handle typematic function.
               *
               * Input: Typematic key
               * ------------------------------------------------------------------------- */
              void check_tm(union KEY key)
              {
                  BYTE sendit;
                  BYTE check;
                  
                      sendit = FALSE;                                                                         
                  check = Byte_Mask((BYTE) (key.field.input)); 
                  if(KB_HW_ExtendKeyTypematic==0x00)
                  {
                      check = check & bscan_matrix[key.field.output];
                  }
                  else
                  {
                      check = check & bscan_matrix[(key.field.output + 16)];
                  }
              
                  if (check == 0)                 // Release Typematic key? 
                  {   
                      typematic.byte = 0;         // Clear Typematic. 
                      sendit = TRUE;
                  }
              
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 30  

                  if (!sendit)
                  {  
                      scan.TMscale--;             // Count down Prescale.
                      if (scan.TMscale != 0) 
                              {
                          sendit = TRUE;
                      }
                  }
              
                  if (!sendit)
                  {
                      scan.TMscale = TM_SCALE;// Reload prescale counter. 
                      bTMcount--;             // Count down TMcount. 
                      if (bTMcount != 0) 
                              {
                          sendit = TRUE;
                      }
                  }
              
                  if (!sendit)
                  {
                      if(KB_HW_ExtendKeyTypematic==0x00)
                      {
                          KB_HW_ExtendKeyIndex=0x00;
                      }
                      else
                      {
                          KB_HW_ExtendKeyIndex=0x01;
                      }
                      bTMcount = bTMrepeat;   // Reload TMcount. 
                      Send_Scan2(key, REPEAT_EVENT);   
                  }
              }
              
              //-----------------------------------------------------------------
              //
              //-----------------------------------------------------------------
              void HW_KB_Check_TM(void)
              {
                  BYTE kso_index;
                      if(typematic.byte) 
                      {
                      check_tm(typematic);        // Check typematic. 
                      }
              
                  if(IS_MASK_SET(SDSR, BIT1))     // All FFh
                  {
                      for(kso_index=0x00; kso_index<(16+ExtendScanPin); kso_index++)
                      {
                          if(bscan_matrix[kso_index]!=0x00)
                          {
                              F_Service_KEY = 1;  // Request scanner service. 
                              break;
                          }
                      }
                  }
              }
              
              //-----------------------------------------------------------------
              //
              //-----------------------------------------------------------------
              void Clear_AllKeysBreak(void)
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 31  

              {
                  Timer_A.fbit.TMR_SCAN = 0;  // Disable the scan timer. 
                  typematic.byte = 0;         // Clear typematic
                  FN_Key_Break = 0x00;        // Clear FN_Key_Break
                  FN_Key_Break_HS = 0x00;
              
                  ClearFnKeyBundledFalg();
                  KB_HW_ExtendKeyIndex = 0x00;
                  KB_HW_ExtendKeyTypematic = 0x00;
              }
              
              //-----------------------------------------------------------------
              //
              //-----------------------------------------------------------------
              void FindGhostKey(void)
              {
              
              
              
              }
              
              //*******************************************************
              #endif  // #ifndef KB_HW_KeyScan  
1874          //*******************************************************
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 32  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION Com00E1 (BEGIN)
0000         L?0226:
0000         L?0227:
0000 E500        E     MOV     A,new_keyh
0002         L?0228:
0002 5407              ANL     A,#07H
0004 FF                MOV     R7,A
0005 7401              MOV     A,#01H
0007 C8                XCH     A,R0
0008 EF                MOV     A,R7
0009 C8                XCH     A,R0
000A 08                INC     R0
000B 22                RET     
000C         L?0229:
000C 7800        E     MOV     R0,#LOW ?Send_Scan2?BYTE
000E 7C00        E     MOV     R4,#HIGH ?Send_Scan2?BYTE
0010 7D01              MOV     R5,#01H
0012         L?0230:
0012 7E00              MOV     R6,#00H
0014 7F01              MOV     R7,#01H
0016 020000      E     LJMP    ?C?COPY
0019         L?0231:
0019 EF                MOV     A,R7
001A C4                SWAP    A
001B 540F              ANL     A,#0FH
001D FE                MOV     R6,A
001E EF                MOV     A,R7
001F 540F              ANL     A,#0FH
0021 FF                MOV     R7,A
0022 EE                MOV     A,R6
0023 14                DEC     A
0024         L?0232:
0024 540F              ANL     A,#0FH
0026 C4                SWAP    A
0027 54F0              ANL     A,#0F0H
0029 4F                ORL     A,R7
002A 22                RET     
002B         L?0233:
002B         L?0234:
002B 900000      E     MOV     DPTR,#KSOL
002E 74FF              MOV     A,#0FFH
0030 F0                MOVX    @DPTR,A
0031 900000      E     MOV     DPTR,#KSOH1
0034 F0                MOVX    @DPTR,A
0035 22                RET     
0036         L?0235:
0036 540F              ANL     A,#0FH
0038 2400        E     ADD     A,#LOW bKEY_BUFF
003A         L?0236:
003A F582              MOV     DPL,A
003C E4                CLR     A
003D 3400        E     ADDC    A,#HIGH bKEY_BUFF
003F F583              MOV     DPH,A
0041 22                RET     
0042         L?0237:
0042 C4                SWAP    A
0043 5401              ANL     A,#01H
0045 2F                ADD     A,R7
0046 FF                MOV     R7,A
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 33  

0047 EE                MOV     A,R6
0048 C4                SWAP    A
0049 13                RRC     A
004A 13                RRC     A
004B 5401              ANL     A,#01H
004D 2F                ADD     A,R7
004E FF                MOV     R7,A
004F 22                RET     
0050         L?0238:
0050 A3                INC     DPTR
0051         L?0239:
0051 E0                MOVX    A,@DPTR
0052 FD                MOV     R5,A
0053 2400        E     ADD     A,#LOW bscan_matrix
0055 F8                MOV     R0,A
0056 E6                MOV     A,@R0
0057 22                RET     
0058         L?0240:
0058 2F                ADD     A,R7
0059 F8                MOV     R0,A
005A E6                MOV     A,@R0
005B FF                MOV     R7,A
005C E500        E     MOV     A,ITempB02
005E F4                CPL     A
005F 6F                XRL     A,R7
0060 F500        E     MOV     ITempB02,A
0062 E500        E     MOV     A,ITempB02
0064 22                RET     
0065         L?0241:
0065 AF00        E     MOV     R7,new_keyh
0067 EF                MOV     A,R7
0068         L?0242:
0068 C4                SWAP    A
0069 540F              ANL     A,#0FH
006B 2400        E     ADD     A,#LOW bscan_matrix
006D F8                MOV     R0,A
006E 22                RET     
006F         L?0243:
006F E4                CLR     A
0070         L?0244:
0070 900000      E     MOV     DPTR,#KSOL
0073 F0                MOVX    @DPTR,A
0074 900000      E     MOV     DPTR,#KSOH1
0077 22                RET     
0078         L?0245:
0078 AF00        E     MOV     R7,new_extendkey
007A EF                MOV     A,R7
007B         L?0246:
007B C4                SWAP    A
007C 540F              ANL     A,#0FH
007E 2400        E     ADD     A,#LOW bscan_matrix+010H
0080 F8                MOV     R0,A
0081 22                RET     
0082         L?0247:
0082 5300EF      E     ANL     scan+02H,#0EFH
0085 5300DF      E     ANL     scan+02H,#0DFH
0088 5300BF      E     ANL     scan+02H,#0BFH
008B 22                RET     
008C         L?0248:
008C         L?0249:
008C 7401              MOV     A,#01H
008E C8                XCH     A,R0
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 34  

008F EF                MOV     A,R7
0090 C8                XCH     A,R0
0091 08                INC     R0
0092 22                RET     
0093         L?0250:
0093 900000      E     MOV     DPTR,#bTMdelay
0096 E0                MOVX    A,@DPTR
0097 900000      E     MOV     DPTR,#bTMcount
009A F0                MOVX    @DPTR,A
009B E4                CLR     A
009C 22                RET     
009D         L?0251:
009D E4                CLR     A
009E 900000      E     MOV     DPTR,#FN_Key_Break
00A1 F0                MOVX    @DPTR,A
00A2 900000      E     MOV     DPTR,#FN_Key_Break_HS
00A5 F0                MOVX    @DPTR,A
00A6 22                RET     
00A7         L?0252:
00A7         L?0253:
00A7 AE00        E     MOV     R6,scan
00A9 EE                MOV     A,R6
00AA C4                SWAP    A
00AB 540F              ANL     A,#0FH
00AD 22                RET     
00AE         L?0254:
00AE         L?0255:
00AE 900000      R     MOV     DPTR,#key
00B1 E0                MOVX    A,@DPTR
00B2 5407              ANL     A,#07H
00B4 22                RET     
             ; FUNCTION Com00E1 (END)

             ; FUNCTION CapDelay (BEGIN)
                                           ; SOURCE LINE # 18
                                           ; SOURCE LINE # 19
                                           ; SOURCE LINE # 20
0000 E4                CLR     A
0001 900000      E     MOV     DPTR,#WNCKR
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 21
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 22
0006 22                RET     
             ; FUNCTION CapDelay (END)

             ; FUNCTION scan_keys (BEGIN)
                                           ; SOURCE LINE # 32
                                           ; SOURCE LINE # 33
                                           ; SOURCE LINE # 35
0000 E4                CLR     A
0001 900000      R     MOV     DPTR,#result
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 37
                                           ; SOURCE LINE # 38
                                           ; SOURCE LINE # 39
0005 120000      R     LCALL   L?0247
                                           ; SOURCE LINE # 41
0008 E500        E     MOV     A,typematic
000A 6012              JZ      ?C0002
                                           ; SOURCE LINE # 42
                                           ; SOURCE LINE # 43
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 35  

000C 7800        R     MOV     R0,#LOW ?check_tm?BYTE
000E 7C00        R     MOV     R4,#HIGH ?check_tm?BYTE
0010 7D01              MOV     R5,#01H
0012 7B00              MOV     R3,#00H
0014 7A00        E     MOV     R2,#HIGH typematic
0016 7900        E     MOV     R1,#LOW typematic
0018 120000      R     LCALL   L?0230
001B 120000      R     LCALL   check_tm
                                           ; SOURCE LINE # 44
001E         ?C0002:
                                           ; SOURCE LINE # 46
001E E500        E     MOV     A,new_keyh
0020 600C              JZ      ?C0003
                                           ; SOURCE LINE # 47
                                           ; SOURCE LINE # 48
0022 430010      E     ORL     scan+02H,#010H
                                           ; SOURCE LINE # 49
0025 120000      R     LCALL   debounce_key
                                           ; SOURCE LINE # 50
0028 900000      R     MOV     DPTR,#result
002B 7401              MOV     A,#01H
002D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 51
002E         ?C0003:
                                           ; SOURCE LINE # 53
002E 900000      R     MOV     DPTR,#result
0031 E0                MOVX    A,@DPTR
0032 7063              JNZ     ?C0004
                                           ; SOURCE LINE # 54
                                           ; SOURCE LINE # 55
0034 F500        E     MOV     ITempB03,A
0036         ?C0005:
                                           ; SOURCE LINE # 56
                                           ; SOURCE LINE # 57
0036 AF00        E     MOV     R7,ITempB03
0038 120000      R     LCALL   _Write_Strobe
                                           ; SOURCE LINE # 58
003B 120000      R     LCALL   CapDelay
                                           ; SOURCE LINE # 59
003E 900000      E     MOV     DPTR,#KSI
0041 E0                MOVX    A,@DPTR
0042 F500        E     MOV     ITempB02,A
                                           ; SOURCE LINE # 60
0044 AF00        E     MOV     R7,ITempB03
0046 7400        E     MOV     A,#LOW bscan_matrix
                                           ; SOURCE LINE # 61
0048 120000      R     LCALL   L?0240
004B 6007              JZ      ?C0008
                                           ; SOURCE LINE # 62
                                           ; SOURCE LINE # 63
004D AD00        E     MOV     R5,ITempB03
004F AF00        E     MOV     R7,ITempB02
0051 120000      R     LCALL   _check_scan
                                           ; SOURCE LINE # 64
0054         ?C0008:
                                           ; SOURCE LINE # 66
0054 AF00        E     MOV     R7,ITempB03
0056 7400        E     MOV     A,#LOW bscan_matrix
0058 2F                ADD     A,R7
0059 F8                MOV     R0,A
005A E6                MOV     A,@R0
005B 6003              JZ      ?C0009
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 36  

                                           ; SOURCE LINE # 67
                                           ; SOURCE LINE # 68
005D 430040      E     ORL     scan+02H,#040H
                                           ; SOURCE LINE # 69
0060         ?C0009:
                                           ; SOURCE LINE # 70
                                           ; SOURCE LINE # 71
0060 120000      R     LCALL   L?0233
                                           ; SOURCE LINE # 72
0063 0500        E     INC     ITempB03
0065 E500        E     MOV     A,ITempB03
0067 C3                CLR     C
0068 9410              SUBB    A,#010H
006A 40CA              JC      ?C0005
006C         ?C0006:
                                           ; SOURCE LINE # 74
006C E500        E     MOV     A,new_keyl
006E 30E326            JNB     ACC.3,?C0004
                                           ; SOURCE LINE # 75
                                           ; SOURCE LINE # 76
0071 5300F7      E     ANL     new_keyl,#0F7H
                                           ; SOURCE LINE # 77
0074 E500        E     MOV     A,new_keyl
0076 5407              ANL     A,#07H
0078 F500        E     MOV     ITempB01,A
                                           ; SOURCE LINE # 78
007A E500        E     MOV     A,ITempB01
007C 7011              JNZ     ?C0011
                                           ; SOURCE LINE # 79
                                           ; SOURCE LINE # 80
007E 120000      R     LCALL   L?0226
0081 8002              SJMP    ?C0187
0083         ?C0186:
0083 C3                CLR     C
0084 33                RLC     A
0085         ?C0187:
0085 D8FC              DJNZ    R0,?C0186
0087 F500        E     MOV     ITempB01,A
                                           ; SOURCE LINE # 81
0089 900000      E     MOV     DPTR,#diode_key
008C E0                MOVX    A,@DPTR
008D 5200        E     ANL     ITempB01,A
                                           ; SOURCE LINE # 82
008F         ?C0011:
                                           ; SOURCE LINE # 84
008F E500        E     MOV     A,ITempB01
0091 7004              JNZ     ?C0004
                                           ; SOURCE LINE # 85
                                           ; SOURCE LINE # 86
0093 F500        E     MOV     new_keyh,A
                                           ; SOURCE LINE # 87
0095 F500        E     MOV     new_keyl,A
                                           ; SOURCE LINE # 88
                                           ; SOURCE LINE # 89
                                           ; SOURCE LINE # 90
0097         ?C0004:
                                           ; SOURCE LINE # 92
0097 AF00        E     MOV     R7,scan+02H
0099 EF                MOV     A,R7
009A C4                SWAP    A
009B 13                RRC     A
009C 5401              ANL     A,#01H
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 37  

009E FF                MOV     R7,A
009F AE00        E     MOV     R6,scan+02H
00A1 EE                MOV     A,R6
00A2 AE00        E     MOV     R6,scan+02H
00A4 120000      R     LCALL   L?0237
                                           ; SOURCE LINE # 93
00A7         ?C0013:
00A7 22                RET     
             ; FUNCTION scan_keys (END)

             ; FUNCTION _Write_Strobe (BEGIN)
                                           ; SOURCE LINE # 111
;---- Variable 'scan_line_num' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 112
                                           ; SOURCE LINE # 113
0000 EF                MOV     A,R7
0001 C3                CLR     C
0002 9408              SUBB    A,#08H
0004 5012              JNC     ?C0014
                                           ; SOURCE LINE # 114
                                           ; SOURCE LINE # 115
0006 120000      R     LCALL   L?0248
0009 8002              SJMP    ?C0189
000B         ?C0188:
000B C3                CLR     C
000C 33                RLC     A
000D         ?C0189:
000D D8FC              DJNZ    R0,?C0188
000F F4                CPL     A
                                           ; SOURCE LINE # 116
0010 120000      R     LCALL   L?0244
0013 74FF              MOV     A,#0FFH
0015 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 117
0016 8018              SJMP    ?C0015
0018         ?C0014:
                                           ; SOURCE LINE # 119
                                           ; SOURCE LINE # 120
0018 900000      E     MOV     DPTR,#KSOL
001B 74FF              MOV     A,#0FFH
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 121
001E EF                MOV     A,R7
001F 24F8              ADD     A,#0F8H
0021 FF                MOV     R7,A
0022 120000      R     LCALL   L?0248
0025 8002              SJMP    ?C0191
0027         ?C0190:
0027 C3                CLR     C
0028 33                RLC     A
0029         ?C0191:
0029 D8FC              DJNZ    R0,?C0190
002B F4                CPL     A
002C 900000      E     MOV     DPTR,#KSOH1
002F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 122
0030         ?C0015:
                                           ; SOURCE LINE # 124
0030 300009      E     JNB     ExtendMatrix,?C0017
                                           ; SOURCE LINE # 125
                                           ; SOURCE LINE # 126
0033 900000      E     MOV     DPTR,#KSOH2
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 38  

0036 74FF              MOV     A,#0FFH
0038 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 127
0039 120000      E     LCALL   Hook_SetGPIOScanPinH
                                           ; SOURCE LINE # 128
                                           ; SOURCE LINE # 129
003C         ?C0017:
003C 22                RET     
             ; FUNCTION _Write_Strobe (END)

             ; FUNCTION _check_scan (BEGIN)
                                           ; SOURCE LINE # 145
0000 900000      R     MOV     DPTR,#changes
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 ED                MOV     A,R5
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 146
                                           ; SOURCE LINE # 151
0008 E4                CLR     A
0009 A3                INC     DPTR
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 152
000B E500        E     MOV     A,new_keyl
000D 30E302            JNB     ACC.3,?C0018
                                           ; SOURCE LINE # 153
                                           ; SOURCE LINE # 154
                                           ; SOURCE LINE # 155
0010 801F              SJMP    ?C0215
0012         ?C0018:
                                           ; SOURCE LINE # 157
                                           ; SOURCE LINE # 158
0012 900000      R     MOV     DPTR,#scan_address
0015 120000      R     LCALL   L?0239
0018 F4                CPL     A
0019 FF                MOV     R7,A
001A 900000      R     MOV     DPTR,#changes
001D E0                MOVX    A,@DPTR
001E 5F                ANL     A,R7
001F FF                MOV     R7,A
;---- Variable 'change_make_key' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 159
0020 7006              JNZ     ?C0020
                                           ; SOURCE LINE # 160
                                           ; SOURCE LINE # 161
0022 900000      R     MOV     DPTR,#flag
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 162
0026 800C              SJMP    ?C0019
0028         ?C0020:
                                           ; SOURCE LINE # 163
0028 120000      R     LCALL   _find_paths
002B EF                MOV     A,R7
002C 6006              JZ      ?C0019
                                           ; SOURCE LINE # 164
                                           ; SOURCE LINE # 165
002E 900000      R     MOV     DPTR,#flag
0031         ?C0215:
0031 7401              MOV     A,#01H
0033 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 166
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 39  

                                           ; SOURCE LINE # 167
0034         ?C0019:
                                           ; SOURCE LINE # 169
0034 900000      R     MOV     DPTR,#flag
0037 E0                MOVX    A,@DPTR
0038 601B              JZ      ?C0023
                                           ; SOURCE LINE # 170
                                           ; SOURCE LINE # 171
003A 430008      E     ORL     new_keyl,#08H
                                           ; SOURCE LINE # 173
003D 900000      R     MOV     DPTR,#changes
0040 E0                MOVX    A,@DPTR
0041 FF                MOV     R7,A
0042 A3                INC     DPTR
0043 E0                MOVX    A,@DPTR
0044 2400        E     ADD     A,#LOW bscan_matrix
0046 F8                MOV     R0,A
0047 E6                MOV     A,@R0
0048 FE                MOV     R6,A
0049 900000      E     MOV     DPTR,#diode_key
004C E0                MOVX    A,@DPTR
004D 4E                ORL     A,R6
004E FE                MOV     R6,A
004F EF                MOV     A,R7
0050 5E                ANL     A,R6
0051 900000      R     MOV     DPTR,#changes
0054 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 174
0055         ?C0023:
                                           ; SOURCE LINE # 176
0055 E4                CLR     A
0056 900000      R     MOV     DPTR,#bit_num
0059 F0                MOVX    @DPTR,A
005A         ?C0024:
                                           ; SOURCE LINE # 177
005A 900000      R     MOV     DPTR,#changes
005D E0                MOVX    A,@DPTR
005E 601F              JZ      ?C0027
                                           ; SOURCE LINE # 178
                                           ; SOURCE LINE # 179
0060 30E00D            JNB     ACC.0,?C0026
                                           ; SOURCE LINE # 180
                                           ; SOURCE LINE # 181
0063 900000      R     MOV     DPTR,#bit_num
0066 E0                MOVX    A,@DPTR
0067 FF                MOV     R7,A
0068 900000      R     MOV     DPTR,#scan_address
006B E0                MOVX    A,@DPTR
006C FD                MOV     R5,A
006D 120000      R     LCALL   _cscfnd
                                           ; SOURCE LINE # 182
0070         ?C0026:
                                           ; SOURCE LINE # 183
0070 900000      R     MOV     DPTR,#bit_num
0073 E0                MOVX    A,@DPTR
0074 04                INC     A
0075 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 184
0076 900000      R     MOV     DPTR,#changes
0079 E0                MOVX    A,@DPTR
007A C3                CLR     C
007B 13                RRC     A
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 40  

007C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 185
007D 80DB              SJMP    ?C0024
                                           ; SOURCE LINE # 186
007F         ?C0027:
007F 22                RET     
             ; FUNCTION _check_scan (END)

             ; FUNCTION _cscfnd (BEGIN)
                                           ; SOURCE LINE # 194
0000 900000      R     MOV     DPTR,#bit_num
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 ED                MOV     A,R5
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 195
                                           ; SOURCE LINE # 196
0008 120000      R     LCALL   L?0239
000B FB                MOV     R3,A
000C 7A00              MOV     R2,#00H
000E 900000      R     MOV     DPTR,#bit_num
0011 E0                MOVX    A,@DPTR
0012 FC                MOV     R4,A
0013 7401              MOV     A,#01H
0015 7E00              MOV     R6,#00H
0017 C8                XCH     A,R0
0018 EC                MOV     A,R4
0019 C8                XCH     A,R0
001A 08                INC     R0
001B 8005              SJMP    ?C0193
001D         ?C0192:
001D C3                CLR     C
001E 33                RLC     A
001F CE                XCH     A,R6
0020 33                RLC     A
0021 CE                XCH     A,R6
0022         ?C0193:
0022 D8F9              DJNZ    R0,?C0192
0024 FF                MOV     R7,A
0025 EE                MOV     A,R6
0026 5A                ANL     A,R2
0027 FE                MOV     R6,A
0028 EF                MOV     A,R7
0029 5B                ANL     A,R3
002A 4E                ORL     A,R6
002B 600F              JZ      ?C0028
                                           ; SOURCE LINE # 197
                                           ; SOURCE LINE # 198
002D E500        E     MOV     A,scan+02H
002F 20E51F            JB      ACC.5,?C0032
                                           ; SOURCE LINE # 199
                                           ; SOURCE LINE # 200
0032 430020      E     ORL     scan+02H,#020H
                                           ; SOURCE LINE # 201
0035 CF                XCH     A,R7
0036 EC                MOV     A,R4
0037 CF                XCH     A,R7
0038 7B01              MOV     R3,#01H
                                           ; SOURCE LINE # 202
                                           ; SOURCE LINE # 203
003A 8012              SJMP    ?C0216
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 41  

003C         ?C0028:
                                           ; SOURCE LINE # 205
                                           ; SOURCE LINE # 206
003C E500        E     MOV     A,scan+02H
003E 20E410            JB      ACC.4,?C0032
                                           ; SOURCE LINE # 207
                                           ; SOURCE LINE # 208
0041 430010      E     ORL     scan+02H,#010H
                                           ; SOURCE LINE # 209
0044 900000      R     MOV     DPTR,#bit_num
0047 E0                MOVX    A,@DPTR
0048 FF                MOV     R7,A
0049 A3                INC     DPTR
004A E0                MOVX    A,@DPTR
004B FD                MOV     R5,A
004C E4                CLR     A
004D FB                MOV     R3,A
004E         ?C0216:
004E 120000      R     LCALL   _setup_debounce
                                           ; SOURCE LINE # 210
                                           ; SOURCE LINE # 211
                                           ; SOURCE LINE # 212
0051         ?C0032:
0051 22                RET     
             ; FUNCTION _cscfnd (END)

             ; FUNCTION _setup_debounce (BEGIN)
                                           ; SOURCE LINE # 222
;---- Variable 'bit_num' assigned to Register 'R7' ----
;---- Variable 'event' assigned to Register 'R3' ----
;---- Variable 'scan_address' assigned to Register 'R5' ----
                                           ; SOURCE LINE # 223
                                           ; SOURCE LINE # 224
0000 ED                MOV     A,R5
0001 540F              ANL     A,#0FH
0003 C4                SWAP    A
0004 54F0              ANL     A,#0F0H
0006 FE                MOV     R6,A
0007 E500        E     MOV     A,new_keyh
0009 540F              ANL     A,#0FH
000B 4E                ORL     A,R6
000C F500        E     MOV     new_keyh,A
                                           ; SOURCE LINE # 225
000E EF                MOV     A,R7
000F 5407              ANL     A,#07H
0011 FF                MOV     R7,A
0012 E500        E     MOV     A,new_keyh
0014 54F8              ANL     A,#0F8H
0016 4F                ORL     A,R7
0017 F500        E     MOV     new_keyh,A
                                           ; SOURCE LINE # 226
0019 430008      E     ORL     new_keyh,#08H
                                           ; SOURCE LINE # 227
001C 5300FE      E     ANL     new_keyl,#0FEH
                                           ; SOURCE LINE # 228
001F 5300EF      E     ANL     new_keyl,#0EFH
                                           ; SOURCE LINE # 230
0022 EB                MOV     A,R3
0023 700D              JNZ     ?C0033
                                           ; SOURCE LINE # 231
                                           ; SOURCE LINE # 232
0025 5300FD      E     ANL     new_keyl,#0FDH
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 42  

                                           ; SOURCE LINE # 233
0028 7800        E     MOV     R0,#LOW Ext_Cb2
002A E6                MOV     A,@R0
002B 540E              ANL     A,#0EH
002D C4                SWAP    A
002E 54F0              ANL     A,#0F0H
                                           ; SOURCE LINE # 234
0030 8008              SJMP    ?C0217
0032         ?C0033:
                                           ; SOURCE LINE # 236
                                           ; SOURCE LINE # 237
0032 430002      E     ORL     new_keyl,#02H
                                           ; SOURCE LINE # 238
0035 7800        E     MOV     R0,#LOW Ext_Cb2
0037 E6                MOV     A,@R0
0038 54E0              ANL     A,#0E0H
003A         ?C0217:
003A FF                MOV     R7,A
003B E500        E     MOV     A,new_keyl
003D 541F              ANL     A,#01FH
003F 4F                ORL     A,R7
0040 F500        E     MOV     new_keyl,A
                                           ; SOURCE LINE # 239
                                           ; SOURCE LINE # 240
0042         ?C0035:
0042 22                RET     
             ; FUNCTION _setup_debounce (END)

             ; FUNCTION _find_paths (BEGIN)
                                           ; SOURCE LINE # 250
;---- Variable 'temp' assigned to Register 'R6' ----
;---- Variable 'paths' assigned to Register 'R4' ----
;---- Variable 'bits' assigned to Register 'R1' ----
;---- Variable 'scan_address' assigned to Register 'R5' ----
;---- Variable 'change_make_key' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 251
                                           ; SOURCE LINE # 260
0000 E4                CLR     A
0001 900000      R     MOV     DPTR,#done
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 261
0005 900000      R     MOV     DPTR,#paths_found
0008 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 262
0009 900000      R     MOV     DPTR,#first_address
000C ED                MOV     A,R5
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 264
000E 900000      E     MOV     DPTR,#diode_key
0011 E0                MOVX    A,@DPTR
0012 F4                CPL     A
0013 5F                ANL     A,R7
0014 FF                MOV     R7,A
                                           ; SOURCE LINE # 267
0015 7005              JNZ     ?C0036
                                           ; SOURCE LINE # 268
                                           ; SOURCE LINE # 269
0017 900000      R     MOV     DPTR,#done
001A 04                INC     A
001B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 270
001C         ?C0036:
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 43  

                                           ; SOURCE LINE # 272
001C 900000      R     MOV     DPTR,#done
001F E0                MOVX    A,@DPTR
0020 7015              JNZ     ?C0039
                                           ; SOURCE LINE # 273
                                           ; SOURCE LINE # 274
0022 7400        E     MOV     A,#LOW bscan_matrix
0024 2D                ADD     A,R5
0025 F8                MOV     R0,A
0026 E6                MOV     A,@R0
0027 4F                ORL     A,R7
0028 FC                MOV     R4,A
                                           ; SOURCE LINE # 275
0029 900000      E     MOV     DPTR,#diode_key
002C E0                MOVX    A,@DPTR
002D F4                CPL     A
002E 5C                ANL     A,R4
002F FC                MOV     R4,A
                                           ; SOURCE LINE # 277
0030 7005              JNZ     ?C0039
                                           ; SOURCE LINE # 278
                                           ; SOURCE LINE # 279
0032 900000      R     MOV     DPTR,#done
0035 04                INC     A
0036 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 280
                                           ; SOURCE LINE # 281
0037         ?C0039:
                                           ; SOURCE LINE # 283
0037 900000      R     MOV     DPTR,#done
003A E0                MOVX    A,@DPTR
003B 705E              JNZ     ?C0040
                                           ; SOURCE LINE # 284
                                           ; SOURCE LINE # 285
003D 0D                INC     R5
                                           ; SOURCE LINE # 287
003E ED                MOV     A,R5
003F C3                CLR     C
0040 9413              SUBB    A,#013H
0042 4002              JC      ?C0041
                                           ; SOURCE LINE # 289
                                           ; SOURCE LINE # 290
0044 E4                CLR     A
0045 FD                MOV     R5,A
                                           ; SOURCE LINE # 291
0046         ?C0041:
                                           ; SOURCE LINE # 293
0046 900000      R     MOV     DPTR,#first_address
0049 E0                MOVX    A,@DPTR
004A 6D                XRL     A,R5
004B 7005              JNZ     ?C0042
                                           ; SOURCE LINE # 294
                                           ; SOURCE LINE # 295
004D 900000      R     MOV     DPTR,#done
0050 04                INC     A
0051 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 296
0052         ?C0042:
                                           ; SOURCE LINE # 298
0052 900000      R     MOV     DPTR,#done
0055 E0                MOVX    A,@DPTR
0056 70DF              JNZ     ?C0039
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 44  

                                           ; SOURCE LINE # 299
                                           ; SOURCE LINE # 300
0058 7400        E     MOV     A,#LOW bscan_matrix
005A 2D                ADD     A,R5
005B F8                MOV     R0,A
005C E6                MOV     A,@R0
005D FE                MOV     R6,A
                                           ; SOURCE LINE # 301
005E 900000      E     MOV     DPTR,#diode_key
0061 E0                MOVX    A,@DPTR
0062 F4                CPL     A
0063 5E                ANL     A,R6
0064 FE                MOV     R6,A
                                           ; SOURCE LINE # 303
0065 6002              JZ      ?C0044
                                           ; SOURCE LINE # 304
                                           ; SOURCE LINE # 305
0067 5C                ANL     A,R4
0068 FE                MOV     R6,A
                                           ; SOURCE LINE # 306
0069         ?C0044:
                                           ; SOURCE LINE # 308
0069 EE                MOV     A,R6
006A 60CB              JZ      ?C0039
                                           ; SOURCE LINE # 309
                                           ; SOURCE LINE # 310
006C 6F                XRL     A,R7
006D 6008              JZ      ?C0046
                                           ; SOURCE LINE # 311
                                           ; SOURCE LINE # 312
006F 900000      R     MOV     DPTR,#paths_found
0072 7401              MOV     A,#01H
0074 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 313
0075 A3                INC     DPTR
0076 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 314
0077         ?C0046:
                                           ; SOURCE LINE # 316
0077 900000      R     MOV     DPTR,#done
007A E0                MOVX    A,@DPTR
007B 70BA              JNZ     ?C0039
                                           ; SOURCE LINE # 317
                                           ; SOURCE LINE # 322
007D C9                XCH     A,R1
007E EC                MOV     A,R4
007F C9                XCH     A,R1
                                           ; SOURCE LINE # 323
0080 FE                MOV     R6,A
0081         ?C0050:
                                           ; SOURCE LINE # 326
                                           ; SOURCE LINE # 327
0081 E9                MOV     A,R1
0082 30E002            JNB     ACC.0,?C0051
                                           ; SOURCE LINE # 328
                                           ; SOURCE LINE # 329
0085 7E01              MOV     R6,#01H
                                           ; SOURCE LINE # 330
0087         ?C0051:
                                           ; SOURCE LINE # 333
0087 E9                MOV     A,R1
0088 C3                CLR     C
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 45  

0089 13                RRC     A
008A F9                MOV     R1,A
                                           ; SOURCE LINE # 334
008B EE                MOV     A,R6
008C 60F3              JZ      ?C0050
                                           ; SOURCE LINE # 336
008E E9                MOV     A,R1
008F 60A6              JZ      ?C0039
                                           ; SOURCE LINE # 337
                                           ; SOURCE LINE # 338
0091 900000      R     MOV     DPTR,#paths_found
0094 7401              MOV     A,#01H
0096 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 339
0097 A3                INC     DPTR
0098 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 340
                                           ; SOURCE LINE # 341
                                           ; SOURCE LINE # 342
                                           ; SOURCE LINE # 343
                                           ; SOURCE LINE # 344
0099 809C              SJMP    ?C0039
009B         ?C0040:
                                           ; SOURCE LINE # 346
009B 900000      R     MOV     DPTR,#paths_found
009E E0                MOVX    A,@DPTR
009F FF                MOV     R7,A
                                           ; SOURCE LINE # 347
00A0         ?C0053:
00A0 22                RET     
             ; FUNCTION _find_paths (END)

             ; FUNCTION debounce_key (BEGIN)
                                           ; SOURCE LINE # 352
                                           ; SOURCE LINE # 353
                                           ; SOURCE LINE # 354
0000 E500        E     MOV     A,new_keyh
0002 54F0              ANL     A,#0F0H
0004 C4                SWAP    A
0005 540F              ANL     A,#0FH
0007 FF                MOV     R7,A
0008 E500        E     MOV     A,scan+02H
000A 54F0              ANL     A,#0F0H
000C 4F                ORL     A,R7
000D F500        E     MOV     scan+02H,A
                                           ; SOURCE LINE # 355
000F 540F              ANL     A,#0FH
0011 FF                MOV     R7,A
0012 120000      R     LCALL   _Write_Strobe
                                           ; SOURCE LINE # 356
0015 120000      R     LCALL   CapDelay
                                           ; SOURCE LINE # 357
0018 120000      R     LCALL   Read_Scan_Lines
001B 8F00        E     MOV     ITempB01,R7
                                           ; SOURCE LINE # 358
001D 6300FF      E     XRL     ITempB01,#0FFH
                                           ; SOURCE LINE # 360
0020 120000      R     LCALL   L?0226
0023 8002              SJMP    ?C0195
0025         ?C0194:
0025 C3                CLR     C
0026 33                RLC     A
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 46  

0027         ?C0195:
0027 D8FC              DJNZ    R0,?C0194
0029 F500        E     MOV     ITempB02,A
                                           ; SOURCE LINE # 361
002B E500        E     MOV     A,ITempB01
002D 5200        E     ANL     ITempB02,A
                                           ; SOURCE LINE # 363
002F E500        E     MOV     A,ITempB02
0031 6007              JZ      ?C0054
                                           ; SOURCE LINE # 364
                                           ; SOURCE LINE # 365
0033 E500        E     MOV     A,new_keyl
0035 20E107            JB      ACC.1,?C0219
                                           ; SOURCE LINE # 366
                                           ; SOURCE LINE # 367
                                           ; SOURCE LINE # 368
0038 800A              SJMP    ?C0218
003A         ?C0054:
                                           ; SOURCE LINE # 375
                                           ; SOURCE LINE # 376
003A E500        E     MOV     A,new_keyl
003C 20E105            JB      ACC.1,?C0058
                                           ; SOURCE LINE # 377
                                           ; SOURCE LINE # 378
003F         ?C0219:
003F 5300EF      E     ANL     new_keyl,#0EFH
                                           ; SOURCE LINE # 379
0042 8003              SJMP    ?C0057
0044         ?C0058:
                                           ; SOURCE LINE # 381
                                           ; SOURCE LINE # 382
0044         ?C0218:
0044 430010      E     ORL     new_keyl,#010H
                                           ; SOURCE LINE # 383
                                           ; SOURCE LINE # 384
0047         ?C0057:
                                           ; SOURCE LINE # 407
                                           ; SOURCE LINE # 408
0047 E500        E     MOV     A,new_keyl
0049 20E406            JB      ACC.4,?C0060
                                           ; SOURCE LINE # 409
                                           ; SOURCE LINE # 410
004C E4                CLR     A
004D F500        E     MOV     new_keyh,A
                                           ; SOURCE LINE # 411
004F F500        E     MOV     new_keyl,A
                                           ; SOURCE LINE # 412
0051 22                RET     
0052         ?C0060:
                                           ; SOURCE LINE # 414
                                           ; SOURCE LINE # 415
0052 120000      R     LCALL   change_valid
                                           ; SOURCE LINE # 416
                                           ; SOURCE LINE # 417
                                           ; SOURCE LINE # 418
0055         ?C0062:
0055 22                RET     
             ; FUNCTION debounce_key (END)

             ; FUNCTION Read_Scan_Lines (BEGIN)
                                           ; SOURCE LINE # 428
                                           ; SOURCE LINE # 429
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 47  

                                           ; SOURCE LINE # 430
0000 900000      E     MOV     DPTR,#KSI
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
                                           ; SOURCE LINE # 431
0005         ?C0063:
0005 22                RET     
             ; FUNCTION Read_Scan_Lines (END)

             ; FUNCTION change_valid (BEGIN)
                                           ; SOURCE LINE # 436
                                           ; SOURCE LINE # 437
                                           ; SOURCE LINE # 438
0000 120000      R     LCALL   L?0227
0003 8002              SJMP    ?C0197
0005         ?C0196:
0005 C3                CLR     C
0006 33                RLC     A
0007         ?C0197:
0007 D8FC              DJNZ    R0,?C0196
0009 F500        E     MOV     ITempB04,A
                                           ; SOURCE LINE # 439
000B 120000      R     LCALL   L?0241
000E E6                MOV     A,@R0
000F F500        E     MOV     ITempB03,A
                                           ; SOURCE LINE # 440
0011 E500        E     MOV     A,ITempB04
0013 6200        E     XRL     ITempB03,A
                                           ; SOURCE LINE # 441
0015 120000      R     LCALL   L?0241
0018 A600        E     MOV     @R0,ITempB03
                                           ; SOURCE LINE # 443
001A 750001      E     MOV     ITempB05,#01H
                                           ; SOURCE LINE # 444
001D E500        E     MOV     A,ITempB04
001F 5500        E     ANL     A,ITempB03
0021 6013              JZ      ?C0064
                                           ; SOURCE LINE # 445
                                           ; SOURCE LINE # 446
0023 E4                CLR     A
0024 F500        E     MOV     ITempB05,A
                                           ; SOURCE LINE # 447
0026 850000      E     MOV     typematic,new_keyh
                                           ; SOURCE LINE # 448
0029 E500        E     MOV     A,scan+01H
002B 540F              ANL     A,#0FH
002D 4420              ORL     A,#020H
002F F500        E     MOV     scan+01H,A
                                           ; SOURCE LINE # 449
                                           ; SOURCE LINE # 451
0031 120000      R     LCALL   L?0250
0034 F500        E     MOV     etkeytypematic,A
                                           ; SOURCE LINE # 452
0036         ?C0064:
                                           ; SOURCE LINE # 454
0036 7B00              MOV     R3,#00H
0038 7A00        E     MOV     R2,#HIGH new_keyh
003A 7900        E     MOV     R1,#LOW new_keyh
003C 120000      R     LCALL   L?0229
003F 900000      E     MOV     DPTR,#?Send_Scan2?BYTE+01H
0042 E500        E     MOV     A,ITempB05
0044 F0                MOVX    @DPTR,A
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 48  

0045 120000      E     LCALL   Send_Scan2
                                           ; SOURCE LINE # 455
0048 E4                CLR     A
0049 F500        E     MOV     new_keyh,A
                                           ; SOURCE LINE # 456
004B F500        E     MOV     new_keyl,A
                                           ; SOURCE LINE # 457
004D 22                RET     
             ; FUNCTION change_valid (END)

             ; FUNCTION check_tm (BEGIN)
                                           ; SOURCE LINE # 464
                                           ; SOURCE LINE # 465
                                           ; SOURCE LINE # 466
0000 E4                CLR     A
0001 F500        E     MOV     ITempB02,A
                                           ; SOURCE LINE # 467
0003 900000      R     MOV     DPTR,#key
0006 E0                MOVX    A,@DPTR
0007 120000      R     LCALL   L?0228
000A 8002              SJMP    ?C0199
000C         ?C0198:
000C C3                CLR     C
000D 33                RLC     A
000E         ?C0199:
000E D8FC              DJNZ    R0,?C0198
0010 F500        E     MOV     ITempB01,A
                                           ; SOURCE LINE # 468
0012 900000      R     MOV     DPTR,#key
0015 E0                MOVX    A,@DPTR
0016 120000      R     LCALL   L?0242
0019 E6                MOV     A,@R0
001A 5200        E     ANL     ITempB01,A
                                           ; SOURCE LINE # 470
001C E500        E     MOV     A,ITempB01
001E 7005              JNZ     ?C0066
                                           ; SOURCE LINE # 471
                                           ; SOURCE LINE # 472
0020 F500        E     MOV     typematic,A
                                           ; SOURCE LINE # 473
0022 750001      E     MOV     ITempB02,#01H
                                           ; SOURCE LINE # 474
0025         ?C0066:
                                           ; SOURCE LINE # 476
0025 E500        E     MOV     A,ITempB02
0027 700F              JNZ     ?C0067
                                           ; SOURCE LINE # 477
                                           ; SOURCE LINE # 478
0029 AF00        E     MOV     R7,scan+01H
002B 120000      R     LCALL   L?0231
002E F500        E     MOV     scan+01H,A
                                           ; SOURCE LINE # 479
0030 C4                SWAP    A
0031 540F              ANL     A,#0FH
0033 6003              JZ      ?C0067
                                           ; SOURCE LINE # 480
                                           ; SOURCE LINE # 481
0035 750001      E     MOV     ITempB02,#01H
                                           ; SOURCE LINE # 482
                                           ; SOURCE LINE # 483
0038         ?C0067:
                                           ; SOURCE LINE # 485
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 49  

0038 E500        E     MOV     A,ITempB02
003A 7014              JNZ     ?C0069
                                           ; SOURCE LINE # 486
                                           ; SOURCE LINE # 487
003C E500        E     MOV     A,scan+01H
003E 540F              ANL     A,#0FH
0040 4420              ORL     A,#020H
0042 F500        E     MOV     scan+01H,A
                                           ; SOURCE LINE # 488
0044 900000      E     MOV     DPTR,#bTMcount
0047 E0                MOVX    A,@DPTR
0048 14                DEC     A
0049 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 489
004A E0                MOVX    A,@DPTR
004B 6003              JZ      ?C0069
                                           ; SOURCE LINE # 490
                                           ; SOURCE LINE # 491
004D 750001      E     MOV     ITempB02,#01H
                                           ; SOURCE LINE # 492
                                           ; SOURCE LINE # 493
0050         ?C0069:
                                           ; SOURCE LINE # 495
0050 E500        E     MOV     A,ITempB02
0052 701A              JNZ     ?C0072
                                           ; SOURCE LINE # 496
                                           ; SOURCE LINE # 497
0054 900000      E     MOV     DPTR,#bTMrepeat
0057 E0                MOVX    A,@DPTR
0058 900000      E     MOV     DPTR,#bTMcount
005B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 498
005C 7B01              MOV     R3,#01H
005E 7A00        R     MOV     R2,#HIGH key
0060 7900        R     MOV     R1,#LOW key
0062 120000      R     LCALL   L?0229
0065 900000      E     MOV     DPTR,#?Send_Scan2?BYTE+01H
0068 7402              MOV     A,#02H
006A F0                MOVX    @DPTR,A
006B 120000      E     LCALL   Send_Scan2
                                           ; SOURCE LINE # 499
                                           ; SOURCE LINE # 500
006E         ?C0072:
006E 22                RET     
             ; FUNCTION check_tm (END)

             ; FUNCTION Scan_Init (BEGIN)
                                           ; SOURCE LINE # 505
                                           ; SOURCE LINE # 506
                                           ; SOURCE LINE # 507
                                           ; SOURCE LINE # 508
0000 120000      R     LCALL   L?0243
0003 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 510
0004 30000A      E     JNB     ExtendMatrix,?C0074
                                           ; SOURCE LINE # 511
                                           ; SOURCE LINE # 512
0007 900000      E     MOV     DPTR,#KSOH2
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 514
000B 120000      E     LCALL   Hook_SetGPIOScanPinCtrl
                                           ; SOURCE LINE # 515
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 50  

000E 120000      E     LCALL   Hook_SetGPIOScanPinL
                                           ; SOURCE LINE # 516
                                           ; SOURCE LINE # 517
0011         ?C0074:
0011 22                RET     
             ; FUNCTION Scan_Init (END)

             ; FUNCTION Enable_Any_Key_Irq (BEGIN)
                                           ; SOURCE LINE # 532
                                           ; SOURCE LINE # 533
                                           ; SOURCE LINE # 534
                                           ; SOURCE LINE # 535
0000 120000      R     LCALL   L?0243
0003 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 537
0004 300007      E     JNB     ExtendMatrix,?C0075
                                           ; SOURCE LINE # 538
                                           ; SOURCE LINE # 539
0007 900000      E     MOV     DPTR,#KSOH2
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 540
000B 120000      E     LCALL   Hook_SetGPIOScanPinL
                                           ; SOURCE LINE # 541
000E         ?C0075:
                                           ; SOURCE LINE # 542
000E 900000      E     MOV     DPTR,#IER1
0011 E0                MOVX    A,@DPTR
0012 4408              ORL     A,#08H
0014 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 543
0015 22                RET     
             ; FUNCTION Enable_Any_Key_Irq (END)

             ; FUNCTION Start_Scan_Transmission (BEGIN)
                                           ; SOURCE LINE # 554
                                           ; SOURCE LINE # 555
                                           ; SOURCE LINE # 558
0000 020000      E     LJMP    SetServiceSendFlag
             ; FUNCTION Start_Scan_Transmission (END)

             ; FUNCTION Check_Scan_Transmission (BEGIN)
                                           ; SOURCE LINE # 568
                                           ; SOURCE LINE # 569
                                           ; SOURCE LINE # 570
0000 E4                CLR     A
0001 900000      R     MOV     DPTR,#allow_transmission
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 572
0005 7800        E     MOV     R0,#LOW Int_Var
0007 E6                MOV     A,@R0
0008 20E717            JB      ACC.7,?C0078
000B 7800        E     MOV     R0,#LOW Flag
000D E6                MOV     A,@R0
000E 20E011            JB      ACC.0,?C0078
                                           ; SOURCE LINE # 573
                                           ; SOURCE LINE # 575
0011 AF00        E     MOV     R7,scan
0013 EF                MOV     A,R7
0014 C4                SWAP    A
0015 540F              ANL     A,#0FH
0017 FF                MOV     R7,A
0018 E500        E     MOV     A,scan
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 51  

001A 540F              ANL     A,#0FH
001C 6F                XRL     A,R7
001D 6003              JZ      ?C0078
                                           ; SOURCE LINE # 576
                                           ; SOURCE LINE # 577
001F 7401              MOV     A,#01H
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 578
                                           ; SOURCE LINE # 579
0022         ?C0078:
                                           ; SOURCE LINE # 581
0022 900000      R     MOV     DPTR,#allow_transmission
0025 E0                MOVX    A,@DPTR
0026 FF                MOV     R7,A
                                           ; SOURCE LINE # 582
0027         ?C0080:
0027 22                RET     
             ; FUNCTION Check_Scan_Transmission (END)

             ; FUNCTION Get_Kbd_Type (BEGIN)
                                           ; SOURCE LINE # 591
                                           ; SOURCE LINE # 592
                                           ; SOURCE LINE # 594
                                           ; SOURCE LINE # 595
                                           ; SOURCE LINE # 596
0000 7F00              MOV     R7,#00H
                                           ; SOURCE LINE # 597
                                           ; SOURCE LINE # 599
                                           ; SOURCE LINE # 600
                                           ; SOURCE LINE # 601
                                           ; SOURCE LINE # 602
0002         ?C0082:
0002 22                RET     
             ; FUNCTION Get_Kbd_Type (END)

             ; FUNCTION Lock_Scan (BEGIN)
                                           ; SOURCE LINE # 610
                                           ; SOURCE LINE # 611
                                           ; SOURCE LINE # 612
0000 7800        E     MOV     R0,#LOW Int_Var
0002 E6                MOV     A,@R0
0003 4480              ORL     A,#080H
0005 F6                MOV     @R0,A
                                           ; SOURCE LINE # 614
0006 22                RET     
             ; FUNCTION Lock_Scan (END)

             ; FUNCTION Unlock_Scan (BEGIN)
                                           ; SOURCE LINE # 619
                                           ; SOURCE LINE # 620
                                           ; SOURCE LINE # 621
0000 7800        E     MOV     R0,#LOW Int_Var
0002 E6                MOV     A,@R0
0003 547F              ANL     A,#07FH
0005 F6                MOV     @R0,A
                                           ; SOURCE LINE # 622
0006 22                RET     
             ; FUNCTION Unlock_Scan (END)

             ; FUNCTION CheckKSO1617Support (BEGIN)
                                           ; SOURCE LINE # 624
                                           ; SOURCE LINE # 625
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 52  

                                           ; SOURCE LINE # 626
0000 E4                CLR     A
0001 900000      E     MOV     DPTR,#ExtendScanPin
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 628
0005 900000      E     MOV     DPTR,#GPCRC3
0008 E0                MOVX    A,@DPTR
0009 54FB              ANL     A,#0FBH
000B 7006              JNZ     ?C0086
                                           ; SOURCE LINE # 629
                                           ; SOURCE LINE # 630
000D 900000      E     MOV     DPTR,#ExtendScanPin
0010 E0                MOVX    A,@DPTR
0011 04                INC     A
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 631
0013         ?C0086:
                                           ; SOURCE LINE # 633
0013 900000      E     MOV     DPTR,#GPCRC5
0016 E0                MOVX    A,@DPTR
0017 54FB              ANL     A,#0FBH
0019 7006              JNZ     ?C0087
                                           ; SOURCE LINE # 634
                                           ; SOURCE LINE # 635
001B 900000      E     MOV     DPTR,#ExtendScanPin
001E E0                MOVX    A,@DPTR
001F 04                INC     A
0020 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 636
0021         ?C0087:
                                           ; SOURCE LINE # 638
0021 900000      E     MOV     DPTR,#ExtendScanPin
0024 E0                MOVX    A,@DPTR
0025 6003              JZ      ?C0088
                                           ; SOURCE LINE # 639
                                           ; SOURCE LINE # 640
0027 D200        E     SETB    ExtendMatrix
                                           ; SOURCE LINE # 641
0029 22                RET     
002A         ?C0088:
                                           ; SOURCE LINE # 643
                                           ; SOURCE LINE # 644
002A C200        E     CLR     ExtendMatrix
                                           ; SOURCE LINE # 645
                                           ; SOURCE LINE # 646
002C         ?C0090:
002C 22                RET     
             ; FUNCTION CheckKSO1617Support (END)

             ; FUNCTION Init_Kbd (BEGIN)
                                           ; SOURCE LINE # 651
                                           ; SOURCE LINE # 652
                                           ; SOURCE LINE # 653
0000 120000      R     LCALL   CheckKSO1617Support
                                           ; SOURCE LINE # 655
0003 120000      R     LCALL   Scan_Init
                                           ; SOURCE LINE # 657
0006 120000      E     LCALL   Hook_Setup_Scanner_Pntr
                                           ; SOURCE LINE # 658
0009 120000      R     LCALL   Setup_Diode_Key
                                           ; SOURCE LINE # 660
000C E4                CLR     A
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 53  

000D F500        E     MOV     new_keyh,A
                                           ; SOURCE LINE # 661
000F F500        E     MOV     new_keyl,A
                                           ; SOURCE LINE # 663
0011 120000      R     LCALL   ClearExtendKeys
                                           ; SOURCE LINE # 665
0014 120000      E     LCALL   Clear_Fn_Keys
                                           ; SOURCE LINE # 666
0017 120000      R     LCALL   Clear_Key
                                           ; SOURCE LINE # 667
001A 120000      R     LCALL   Clear_Typematic
                                           ; SOURCE LINE # 669
001D 120000      R     LCALL   Enable_Any_Key_Irq
                                           ; SOURCE LINE # 671
                                           ; SOURCE LINE # 672
0020 120000      R     LCALL   L?0251
                                           ; SOURCE LINE # 674
0023 020000      E     LJMP    ClearFnKeyBundledFalg
             ; FUNCTION Init_Kbd (END)

             ; FUNCTION Setup_Diode_Key (BEGIN)
                                           ; SOURCE LINE # 684
                                           ; SOURCE LINE # 685
                                           ; SOURCE LINE # 686
                                           ; SOURCE LINE # 687
                                           ; SOURCE LINE # 689
0000 E4                CLR     A
0001 900000      E     MOV     DPTR,#diode_key
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 690
                                           ; SOURCE LINE # 692
                                           ; SOURCE LINE # 693
                                           ; SOURCE LINE # 694
                                           ; SOURCE LINE # 695
0005         ?C0094:
0005 22                RET     
             ; FUNCTION Setup_Diode_Key (END)

             ; FUNCTION Clear_Key (BEGIN)
                                           ; SOURCE LINE # 701
                                           ; SOURCE LINE # 702
                                           ; SOURCE LINE # 706
;---- Variable 'i' assigned to Register 'R7' ----
0000         ?C0095:
                                           ; SOURCE LINE # 707
                                           ; SOURCE LINE # 708
0000 7F13              MOV     R7,#013H
0002 7800        E     MOV     R0,#LOW bscan_matrix
0004 E4                CLR     A
0005         ?C0200:
0005 F6                MOV     @R0,A
0006 08                INC     R0
0007 DFFC              DJNZ    R7,?C0200
                                           ; SOURCE LINE # 709
0009         ?C0096:
                                           ; SOURCE LINE # 711
0009         ?C0098:
                                           ; SOURCE LINE # 712
                                           ; SOURCE LINE # 713
0009 7F10              MOV     R7,#010H
000B 900000      E     MOV     DPTR,#bKEY_BUFF
000E E4                CLR     A
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 54  

000F         ?C0201:
000F F0                MOVX    @DPTR,A
0010 A3                INC     DPTR
0011 DFFC              DJNZ    R7,?C0201
                                           ; SOURCE LINE # 714
0013         ?C0099:
                                           ; SOURCE LINE # 716
0013 5300F0      E     ANL     scan,#0F0H
                                           ; SOURCE LINE # 717
0016 53000F      E     ANL     scan,#0FH
                                           ; SOURCE LINE # 718
0019 E4                CLR     A
001A F500        E     MOV     typematic,A
                                           ; SOURCE LINE # 719
                                           ; SOURCE LINE # 720
                                           ; SOURCE LINE # 721
001C 120000      R     LCALL   L?0247
                                           ; SOURCE LINE # 722
001F 5300F0      E     ANL     scan+02H,#0F0H
                                           ; SOURCE LINE # 723
0022 22                RET     
             ; FUNCTION Clear_Key (END)

             ; FUNCTION Clear_Typematic (BEGIN)
                                           ; SOURCE LINE # 729
                                           ; SOURCE LINE # 730
                                           ; SOURCE LINE # 731
0000 E4                CLR     A
0001 F500        E     MOV     typematic,A
                                           ; SOURCE LINE # 732
0003 900000      E     MOV     DPTR,#bTMdelay
0006 743C              MOV     A,#03CH
0008 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 733
0009 900000      E     MOV     DPTR,#bTMrepeat
000C 7403              MOV     A,#03H
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 734
000F 22                RET     
             ; FUNCTION Clear_Typematic (END)

             ; FUNCTION _Set_Typematic (BEGIN)
                                           ; SOURCE LINE # 757
0000 900000      R     MOV     DPTR,#type_rate
0003 EE                MOV     A,R6
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 758
                                           ; SOURCE LINE # 759
0008 900000      R     MOV     DPTR,#type_rate
000B E0                MOVX    A,@DPTR
000C A3                INC     DPTR
000D E0                MOVX    A,@DPTR
000E 7800        E     MOV     R0,#LOW Save_Typematic
0010 F6                MOV     @R0,A
                                           ; SOURCE LINE # 762
0011 7E00              MOV     R6,#00H
0013 900000      R     MOV     DPTR,#type_rate+01H
0016 E0                MOVX    A,@DPTR
0017 541F              ANL     A,#01FH
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 55  

0019 2400        R     ADD     A,#LOW repeat_tbl
001B F582              MOV     DPL,A
001D EE                MOV     A,R6
001E 3400        R     ADDC    A,#HIGH repeat_tbl
0020 F583              MOV     DPH,A
0022 E4                CLR     A
0023 93                MOVC    A,@A+DPTR
0024 900000      E     MOV     DPTR,#bTMrepeat
0027 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 765
0028 900000      R     MOV     DPTR,#type_rate
002B E0                MOVX    A,@DPTR
002C FE                MOV     R6,A
002D A3                INC     DPTR
002E E0                MOVX    A,@DPTR
002F 7805              MOV     R0,#05H
0031         ?C0202:
0031 CE                XCH     A,R6
0032 C3                CLR     C
0033 13                RRC     A
0034 CE                XCH     A,R6
0035 13                RRC     A
0036 D8F9              DJNZ    R0,?C0202
0038 7E00              MOV     R6,#00H
003A 5403              ANL     A,#03H
003C 2400        R     ADD     A,#LOW delay_tbl
003E F582              MOV     DPL,A
0040 EE                MOV     A,R6
0041 3400        R     ADDC    A,#HIGH delay_tbl
0043 F583              MOV     DPH,A
0045 E4                CLR     A
0046 93                MOVC    A,@A+DPTR
0047 900000      E     MOV     DPTR,#bTMdelay
004A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 766
004B 22                RET     
             ; FUNCTION _Set_Typematic (END)

             ; FUNCTION service_scan (BEGIN)
                                           ; SOURCE LINE # 772
                                           ; SOURCE LINE # 773
                                           ; SOURCE LINE # 776
0000 E500        E     MOV     A,Timer_A
0002 20E403            JB      ACC.4,?C0104
                                           ; SOURCE LINE # 777
                                           ; SOURCE LINE # 778
0005 430010      E     ORL     Timer_A,#010H
                                           ; SOURCE LINE # 779
0008         ?C0104:
                                           ; SOURCE LINE # 781
0008 300012      E     JNB     ExtendMatrix,?C0105
                                           ; SOURCE LINE # 782
                                           ; SOURCE LINE # 783
000B 120000      R     LCALL   bScanExtendKeys
000E EF                MOV     A,R7
000F C0E0              PUSH    ACC
0011 120000      R     LCALL   scan_keys
0014 D0E0              POP     ACC
0016 4F                ORL     A,R7
0017 900000      R     MOV     DPTR,#scan_activity
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 784
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 56  

001B 8008              SJMP    ?C0106
001D         ?C0105:
                                           ; SOURCE LINE # 786
                                           ; SOURCE LINE # 787
001D 120000      R     LCALL   scan_keys
0020 900000      R     MOV     DPTR,#scan_activity
0023 EF                MOV     A,R7
0024 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 788
0025         ?C0106:
                                           ; SOURCE LINE # 790
0025 900000      R     MOV     DPTR,#scan_activity
0028 E0                MOVX    A,@DPTR
0029 700E              JNZ     ?C0108
                                           ; SOURCE LINE # 791
                                           ; SOURCE LINE # 793
002B         ?C0107:
                                           ; SOURCE LINE # 795
                                           ; SOURCE LINE # 796
002B 5300EF      E     ANL     Timer_A,#0EFH
                                           ; SOURCE LINE # 797
002E C200        E     CLR     F_Service_KEY
                                           ; SOURCE LINE # 798
0030 120000      R     LCALL   Enable_Any_Key_Irq
                                           ; SOURCE LINE # 799
                                           ; SOURCE LINE # 800
0033 120000      R     LCALL   L?0251
                                           ; SOURCE LINE # 802
0036 120000      E     LCALL   ClearFnKeyBundledFalg
                                           ; SOURCE LINE # 803
0039         ?C0108:
                                           ; SOURCE LINE # 805
0039 E500        E     MOV     A,Timer_B
003B 20E409            JB      ACC.4,?C0111
                                           ; SOURCE LINE # 806
                                           ; SOURCE LINE # 807
003E 120000      R     LCALL   Check_Scan_Transmission
0041 EF                MOV     A,R7
0042 6003              JZ      ?C0111
                                           ; SOURCE LINE # 808
                                           ; SOURCE LINE # 809
0044 120000      R     LCALL   Start_Scan_Transmission
                                           ; SOURCE LINE # 810
                                           ; SOURCE LINE # 811
                                           ; SOURCE LINE # 812
0047         ?C0111:
0047 22                RET     
             ; FUNCTION service_scan (END)

             ; FUNCTION Get_Buffer (BEGIN)
                                           ; SOURCE LINE # 828
;---- Variable 'buffer_data' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 829
                                           ; SOURCE LINE # 833
0000 120000      R     LCALL   L?0252
0003 FE                MOV     R6,A
0004 E500        E     MOV     A,scan
0006 540F              ANL     A,#0FH
0008 6E                XRL     A,R6
0009 6026              JZ      ?C0112
                                           ; SOURCE LINE # 834
                                           ; SOURCE LINE # 836
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 57  

000B AE00        E     MOV     R6,scan
000D EE                MOV     A,R6
000E 54F0              ANL     A,#0F0H
0010 FD                MOV     R5,A
0011 EE                MOV     A,R6
0012 540F              ANL     A,#0FH
0014 FE                MOV     R6,A
0015 04                INC     A
0016 540F              ANL     A,#0FH
0018 4D                ORL     A,R5
0019 F500        E     MOV     scan,A
001B 7400        E     MOV     A,#LOW bKEY_BUFF
001D 2E                ADD     A,R6
001E 120000      R     LCALL   L?0236
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
                                           ; SOURCE LINE # 837
0023 E500        E     MOV     A,scan
0025 540F              ANL     A,#0FH
0027 C3                CLR     C
0028 9410              SUBB    A,#010H
002A 4007              JC      ?C0114
                                           ; SOURCE LINE # 838
                                           ; SOURCE LINE # 839
002C 5300F0      E     ANL     scan,#0F0H
                                           ; SOURCE LINE # 840
                                           ; SOURCE LINE # 841
002F 8002              SJMP    ?C0114
0031         ?C0112:
                                           ; SOURCE LINE # 843
                                           ; SOURCE LINE # 844
0031 7FFF              MOV     R7,#0FFH
                                           ; SOURCE LINE # 845
0033         ?C0114:
                                           ; SOURCE LINE # 846
                                           ; SOURCE LINE # 847
0033         ?C0115:
0033 22                RET     
             ; FUNCTION Get_Buffer (END)

             ; FUNCTION Buffer_Mark (BEGIN)
                                           ; SOURCE LINE # 852
                                           ; SOURCE LINE # 853
                                           ; SOURCE LINE # 854
0000 E500        E     MOV     A,scan
0002 54F0              ANL     A,#0F0H
0004 C4                SWAP    A
0005 540F              ANL     A,#0FH
0007 FF                MOV     R7,A
0008 E500        E     MOV     A,scan+01H
000A 54F0              ANL     A,#0F0H
000C 4F                ORL     A,R7
000D F500        E     MOV     scan+01H,A
                                           ; SOURCE LINE # 855
000F 22                RET     
             ; FUNCTION Buffer_Mark (END)

             ; FUNCTION _Buffer_Key (BEGIN)
                                           ; SOURCE LINE # 863
;---- Variable 'row_column' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 864
                                           ; SOURCE LINE # 865
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 58  

0000 900000      R     MOV     DPTR,#ready
0003 7401              MOV     A,#01H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 867
0006 120000      R     LCALL   L?0252
0009 FE                MOV     R6,A
000A 120000      R     LCALL   L?0235
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 868
000F E500        E     MOV     A,scan
0011 540F              ANL     A,#0FH
0013 FF                MOV     R7,A
0014 EE                MOV     A,R6
0015 04                INC     A
0016 120000      R     LCALL   L?0232
0019 F500        E     MOV     scan,A
                                           ; SOURCE LINE # 870
001B C4                SWAP    A
001C 540F              ANL     A,#0FH
001E C3                CLR     C
001F 9410              SUBB    A,#010H
0021 4003              JC      ?C0117
                                           ; SOURCE LINE # 871
                                           ; SOURCE LINE # 872
0023 53000F      E     ANL     scan,#0FH
                                           ; SOURCE LINE # 873
0026         ?C0117:
                                           ; SOURCE LINE # 876
0026 E500        E     MOV     A,scan
0028 540F              ANL     A,#0FH
002A FF                MOV     R7,A
002B 120000      R     LCALL   L?0253
002E 6F                XRL     A,R7
002F 7019              JNZ     ?C0118
                                           ; SOURCE LINE # 877
                                           ; SOURCE LINE # 878
0031 E500        E     MOV     A,scan+01H
0033 540F              ANL     A,#0FH
0035 C4                SWAP    A
0036 54F0              ANL     A,#0F0H
0038 FF                MOV     R7,A
0039 E500        E     MOV     A,scan
003B 540F              ANL     A,#0FH
003D 4F                ORL     A,R7
003E F500        E     MOV     scan,A
                                           ; SOURCE LINE # 879
0040 C4                SWAP    A
0041 120000      R     LCALL   L?0235
0044 E4                CLR     A
0045 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 880
0046 900000      R     MOV     DPTR,#ready
0049 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 881
004A         ?C0118:
                                           ; SOURCE LINE # 883
004A 900000      R     MOV     DPTR,#ready
004D E0                MOVX    A,@DPTR
004E FF                MOV     R7,A
                                           ; SOURCE LINE # 884
004F         ?C0119:
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 59  

004F 22                RET     
             ; FUNCTION _Buffer_Key (END)

             ; FUNCTION _Buffer_String (BEGIN)
                                           ; SOURCE LINE # 896
0000 900000      R     MOV     DPTR,#pntr
0003 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 897
                                           ; SOURCE LINE # 898
;---- Variable 'error' assigned to Register 'R5' ----
0006 E4                CLR     A
0007 FD                MOV     R5,A
0008         ?C0120:
                                           ; SOURCE LINE # 900
0008 900000      R     MOV     DPTR,#pntr
000B 120000      E     LCALL   ?C?PLDXDATA
000E 120000      E     LCALL   ?C?CLDPTR
0011 601A              JZ      ?C0121
0013 ED                MOV     A,R5
0014 7017              JNZ     ?C0121
                                           ; SOURCE LINE # 901
                                           ; SOURCE LINE # 902
0016 900000      R     MOV     DPTR,#pntr
0019 75F001            MOV     B,#01H
001C 120000      E     LCALL   ?C?PLDIXDATA
001F 120000      E     LCALL   ?C?CLDPTR
0022 FF                MOV     R7,A
0023 120000      R     LCALL   _Buffer_Key
0026 EF                MOV     A,R7
0027 70DF              JNZ     ?C0120
                                           ; SOURCE LINE # 903
0029 7D80              MOV     R5,#080H
                                           ; SOURCE LINE # 904
                                           ; SOURCE LINE # 905
002B 80DB              SJMP    ?C0120
002D         ?C0121:
                                           ; SOURCE LINE # 907
002D CF                XCH     A,R7
002E ED                MOV     A,R5
002F CF                XCH     A,R7
                                           ; SOURCE LINE # 908
0030         ?C0123:
0030 22                RET     
             ; FUNCTION _Buffer_String (END)

             ; FUNCTION bScanExtendKeys (BEGIN)
                                           ; SOURCE LINE # 916
                                           ; SOURCE LINE # 917
                                           ; SOURCE LINE # 918
0000 E4                CLR     A
0001 F500        E     MOV     ITempB06,A
                                           ; SOURCE LINE # 919
0003 5300DF      E     ANL     extendscan+02H,#0DFH
                                           ; SOURCE LINE # 920
0006 5300EF      E     ANL     extendscan+02H,#0EFH
                                           ; SOURCE LINE # 921
0009 5300BF      E     ANL     extendscan+02H,#0BFH
                                           ; SOURCE LINE # 923
000C E500        E     MOV     A,etkeytypematic
000E 6012              JZ      ?C0124
                                           ; SOURCE LINE # 924
                                           ; SOURCE LINE # 925
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 60  

0010 7800        R     MOV     R0,#LOW ?CheckEtKeystm?BYTE
0012 7C00        R     MOV     R4,#HIGH ?CheckEtKeystm?BYTE
0014 7D01              MOV     R5,#01H
0016 7B00              MOV     R3,#00H
0018 7A00        E     MOV     R2,#HIGH etkeytypematic
001A 7900        E     MOV     R1,#LOW etkeytypematic
001C 120000      R     LCALL   L?0230
001F 120000      R     LCALL   CheckEtKeystm
                                           ; SOURCE LINE # 926
0022         ?C0124:
                                           ; SOURCE LINE # 928
0022 E500        E     MOV     A,new_extendkey
0024 6009              JZ      ?C0125
                                           ; SOURCE LINE # 929
                                           ; SOURCE LINE # 930
0026 430010      E     ORL     extendscan+02H,#010H
                                           ; SOURCE LINE # 931
0029 120000      R     LCALL   DebounceExtendkey
                                           ; SOURCE LINE # 932
002C 750001      E     MOV     ITempB06,#01H
                                           ; SOURCE LINE # 933
002F         ?C0125:
                                           ; SOURCE LINE # 935
002F E500        E     MOV     A,ITempB06
0031 704A              JNZ     ?C0126
                                           ; SOURCE LINE # 936
                                           ; SOURCE LINE # 937
0033 F500        E     MOV     ITempB01,A
0035         ?C0127:
0035 900000      E     MOV     DPTR,#ExtendScanPin
0038 E0                MOVX    A,@DPTR
0039 FF                MOV     R7,A
003A E500        E     MOV     A,ITempB01
003C C3                CLR     C
003D 9F                SUBB    A,R7
003E 503D              JNC     ?C0126
                                           ; SOURCE LINE # 938
                                           ; SOURCE LINE # 939
0040 AF00        E     MOV     R7,ITempB01
0042 120000      R     LCALL   _SetExtendScanLines
                                           ; SOURCE LINE # 940
0045 900000      E     MOV     DPTR,#KSI
0048 E0                MOVX    A,@DPTR
0049 F500        E     MOV     ITempB02,A
                                           ; SOURCE LINE # 941
004B AF00        E     MOV     R7,ITempB01
004D 7400        E     MOV     A,#LOW bscan_matrix+010H
                                           ; SOURCE LINE # 942
004F 120000      R     LCALL   L?0240
0052 6010              JZ      ?C0130
                                           ; SOURCE LINE # 943
                                           ; SOURCE LINE # 944
0054 AF00        E     MOV     R7,ITempB02
0056 7E00              MOV     R6,#00H
0058 AD00        E     MOV     R5,ITempB01
005A ED                MOV     A,R5
005B 2410              ADD     A,#010H
005D FD                MOV     R5,A
005E E4                CLR     A
005F 33                RLC     A
0060 FC                MOV     R4,A
0061 120000      R     LCALL   _CheckExtendKeys
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 61  

                                           ; SOURCE LINE # 945
0064         ?C0130:
                                           ; SOURCE LINE # 947
0064 AF00        E     MOV     R7,ITempB01
0066 7400        E     MOV     A,#LOW bscan_matrix+010H
0068 2F                ADD     A,R7
0069 F8                MOV     R0,A
006A E6                MOV     A,@R0
006B 6003              JZ      ?C0131
                                           ; SOURCE LINE # 948
                                           ; SOURCE LINE # 949
006D 430040      E     ORL     extendscan+02H,#040H
                                           ; SOURCE LINE # 950
0070         ?C0131:
                                           ; SOURCE LINE # 952
0070 900000      E     MOV     DPTR,#KSOH2
0073 74FF              MOV     A,#0FFH
0075 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 953
0076 120000      E     LCALL   Hook_SetGPIOScanPinH
                                           ; SOURCE LINE # 954
0079 0500        E     INC     ITempB01
007B 80B8              SJMP    ?C0127
                                           ; SOURCE LINE # 955
007D         ?C0126:
                                           ; SOURCE LINE # 957
007D E500        E     MOV     A,extendstatus
007F 30E328            JNB     ACC.3,?C0132
                                           ; SOURCE LINE # 958
                                           ; SOURCE LINE # 959
0082 5300F7      E     ANL     extendstatus,#0F7H
                                           ; SOURCE LINE # 960
0085 E500        E     MOV     A,extendstatus
0087 5407              ANL     A,#07H
0089 F500        E     MOV     ITempB01,A
                                           ; SOURCE LINE # 961
008B E500        E     MOV     A,ITempB01
008D 7013              JNZ     ?C0133
                                           ; SOURCE LINE # 962
                                           ; SOURCE LINE # 963
008F E500        E     MOV     A,new_extendkey
0091 120000      R     LCALL   L?0228
0094 8002              SJMP    ?C0204
0096         ?C0203:
0096 C3                CLR     C
0097 33                RLC     A
0098         ?C0204:
0098 D8FC              DJNZ    R0,?C0203
009A F500        E     MOV     ITempB01,A
                                           ; SOURCE LINE # 964
009C 900000      E     MOV     DPTR,#diode_key
009F E0                MOVX    A,@DPTR
00A0 5200        E     ANL     ITempB01,A
                                           ; SOURCE LINE # 965
00A2         ?C0133:
                                           ; SOURCE LINE # 966
00A2 E500        E     MOV     A,ITempB01
00A4 7004              JNZ     ?C0132
                                           ; SOURCE LINE # 967
                                           ; SOURCE LINE # 968
00A6 F500        E     MOV     new_extendkey,A
                                           ; SOURCE LINE # 969
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 62  

00A8 F500        E     MOV     extendstatus,A
                                           ; SOURCE LINE # 970
                                           ; SOURCE LINE # 971
00AA         ?C0132:
                                           ; SOURCE LINE # 973
00AA AF00        E     MOV     R7,extendscan+02H
00AC EF                MOV     A,R7
00AD C4                SWAP    A
00AE 13                RRC     A
00AF 5401              ANL     A,#01H
00B1 FF                MOV     R7,A
00B2 AE00        E     MOV     R6,extendscan+02H
00B4 EE                MOV     A,R6
00B5 AE00        E     MOV     R6,extendscan+02H
00B7 120000      R     LCALL   L?0237
                                           ; SOURCE LINE # 974
00BA         ?C0135:
00BA 22                RET     
             ; FUNCTION bScanExtendKeys (END)

             ; FUNCTION _SetExtendScanLines (BEGIN)
                                           ; SOURCE LINE # 979
;---- Variable 'scan_line' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 980
                                           ; SOURCE LINE # 981
0000 EF                MOV     A,R7
0001 C3                CLR     C
0002 9402              SUBB    A,#02H
0004 5016              JNC     ?C0136
                                           ; SOURCE LINE # 982
                                           ; SOURCE LINE # 983
                                           ; SOURCE LINE # 984
0006 120000      R     LCALL   L?0233
                                           ; SOURCE LINE # 985
0009 120000      R     LCALL   L?0249
000C 8002              SJMP    ?C0206
000E         ?C0205:
000E C3                CLR     C
000F 33                RLC     A
0010         ?C0206:
0010 D8FC              DJNZ    R0,?C0205
0012 F4                CPL     A
0013 900000      E     MOV     DPTR,#KSOH2
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 986
0017 120000      E     LCALL   Hook_SetGPIOScanPinH
                                           ; SOURCE LINE # 987
001A 800A              SJMP    ?C0137
001C         ?C0136:
                                           ; SOURCE LINE # 989
                                           ; SOURCE LINE # 990
                                           ; SOURCE LINE # 991
001C 120000      R     LCALL   L?0234
                                           ; SOURCE LINE # 992
001F 900000      E     MOV     DPTR,#KSOH2
0022 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 993
0023 120000      E     LCALL   Hook_SetGPIOScanPinL
                                           ; SOURCE LINE # 994
0026         ?C0137:
                                           ; SOURCE LINE # 995
0026 020000      R     LJMP    CapDelay
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 63  

             ; FUNCTION _SetExtendScanLines (END)

             ; FUNCTION _CheckExtendKeys (BEGIN)
                                           ; SOURCE LINE # 1001
0000 900000      R     MOV     DPTR,#KSI_bit_num
0003 EE                MOV     A,R6
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
0008 A3                INC     DPTR
0009 EC                MOV     A,R4
000A F0                MOVX    @DPTR,A
000B A3                INC     DPTR
000C ED                MOV     A,R5
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1002
                                           ; SOURCE LINE # 1006
;---- Variable 'flag' assigned to Register 'R3' ----
000E E4                CLR     A
000F FB                MOV     R3,A
                                           ; SOURCE LINE # 1007
0010 E500        E     MOV     A,extendstatus
0012 30E303            JNB     ACC.3,?C0139
                                           ; SOURCE LINE # 1008
                                           ; SOURCE LINE # 1009
0015 0B                INC     R3
                                           ; SOURCE LINE # 1010
0016 801C              SJMP    ?C0140
0018         ?C0139:
                                           ; SOURCE LINE # 1012
                                           ; SOURCE LINE # 1013
0018 900000      R     MOV     DPTR,#scan_address
001B 120000      R     LCALL   L?0238
001E F4                CPL     A
001F FF                MOV     R7,A
0020 900000      R     MOV     DPTR,#KSI_bit_num
0023 A3                INC     DPTR
0024 E0                MOVX    A,@DPTR
0025 5F                ANL     A,R7
0026 FF                MOV     R7,A
;---- Variable 'change_make_key' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1014
0027 7003              JNZ     ?C0141
                                           ; SOURCE LINE # 1015
                                           ; SOURCE LINE # 1016
0029 FB                MOV     R3,A
                                           ; SOURCE LINE # 1017
002A 8008              SJMP    ?C0140
002C         ?C0141:
                                           ; SOURCE LINE # 1018
002C 120000      R     LCALL   _find_paths
002F EF                MOV     A,R7
0030 6002              JZ      ?C0140
                                           ; SOURCE LINE # 1019
                                           ; SOURCE LINE # 1020
0032 7B01              MOV     R3,#01H
                                           ; SOURCE LINE # 1021
                                           ; SOURCE LINE # 1022
0034         ?C0140:
                                           ; SOURCE LINE # 1024
0034 EB                MOV     A,R3
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 64  

0035 601C              JZ      ?C0144
                                           ; SOURCE LINE # 1025
                                           ; SOURCE LINE # 1026
0037 430008      E     ORL     extendstatus,#08H
                                           ; SOURCE LINE # 1027
003A 900000      R     MOV     DPTR,#scan_address
003D A3                INC     DPTR
003E E0                MOVX    A,@DPTR
003F 2400        E     ADD     A,#LOW bscan_matrix
0041 F8                MOV     R0,A
0042 E6                MOV     A,@R0
0043 FF                MOV     R7,A
0044 900000      E     MOV     DPTR,#diode_key
0047 E0                MOVX    A,@DPTR
0048 4F                ORL     A,R7
0049 FF                MOV     R7,A
004A 900000      R     MOV     DPTR,#KSI_bit_num
004D E4                CLR     A
004E F0                MOVX    @DPTR,A
004F A3                INC     DPTR
0050 E0                MOVX    A,@DPTR
0051 5F                ANL     A,R7
0052 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1028
0053         ?C0144:
                                           ; SOURCE LINE # 1030
0053 E4                CLR     A
0054 F500        E     MOV     ITempB03,A
0056         ?C0145:
                                           ; SOURCE LINE # 1031
0056 900000      R     MOV     DPTR,#KSI_bit_num
0059 E0                MOVX    A,@DPTR
005A FE                MOV     R6,A
005B A3                INC     DPTR
005C E0                MOVX    A,@DPTR
005D FF                MOV     R7,A
005E 4E                ORL     A,R6
005F 6058              JZ      ?C0152
                                           ; SOURCE LINE # 1032
                                           ; SOURCE LINE # 1033
0061 EF                MOV     A,R7
0062 30E044            JNB     ACC.0,?C0147
                                           ; SOURCE LINE # 1034
                                           ; SOURCE LINE # 1035
0065 A3                INC     DPTR
0066 120000      R     LCALL   L?0238
0069 FB                MOV     R3,A
006A 7A00              MOV     R2,#00H
006C AF00        E     MOV     R7,ITempB03
006E 7401              MOV     A,#01H
0070 7E00              MOV     R6,#00H
0072 C8                XCH     A,R0
0073 EF                MOV     A,R7
0074 C8                XCH     A,R0
0075 08                INC     R0
0076 8005              SJMP    ?C0208
0078         ?C0207:
0078 C3                CLR     C
0079 33                RLC     A
007A CE                XCH     A,R6
007B 33                RLC     A
007C CE                XCH     A,R6
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 65  

007D         ?C0208:
007D D8F9              DJNZ    R0,?C0207
007F FF                MOV     R7,A
0080 EE                MOV     A,R6
0081 5A                ANL     A,R2
0082 FE                MOV     R6,A
0083 EF                MOV     A,R7
0084 5B                ANL     A,R3
0085 4E                ORL     A,R6
0086 600C              JZ      ?C0148
                                           ; SOURCE LINE # 1036
                                           ; SOURCE LINE # 1037
0088 E500        E     MOV     A,extendscan+02H
008A 20E51C            JB      ACC.5,?C0147
                                           ; SOURCE LINE # 1038
                                           ; SOURCE LINE # 1039
008D 430020      E     ORL     extendscan+02H,#020H
                                           ; SOURCE LINE # 1040
0090 7B01              MOV     R3,#01H
                                           ; SOURCE LINE # 1041
                                           ; SOURCE LINE # 1042
0092 8010              SJMP    ?C0220
0094         ?C0148:
                                           ; SOURCE LINE # 1044
                                           ; SOURCE LINE # 1045
0094 E500        E     MOV     A,extendscan+02H
0096 20E410            JB      ACC.4,?C0147
                                           ; SOURCE LINE # 1046
                                           ; SOURCE LINE # 1047
0099 430010      E     ORL     extendscan+02H,#010H
                                           ; SOURCE LINE # 1048
009C 900000      R     MOV     DPTR,#scan_address
009F A3                INC     DPTR
00A0 E0                MOVX    A,@DPTR
00A1 FD                MOV     R5,A
00A2 E4                CLR     A
00A3 FB                MOV     R3,A
00A4         ?C0220:
00A4 AF00        E     MOV     R7,ITempB03
00A6 120000      R     LCALL   _ExtendKeyDebounce
                                           ; SOURCE LINE # 1049
                                           ; SOURCE LINE # 1050
                                           ; SOURCE LINE # 1051
00A9         ?C0147:
                                           ; SOURCE LINE # 1052
00A9 0500        E     INC     ITempB03
                                           ; SOURCE LINE # 1053
00AB 900000      R     MOV     DPTR,#KSI_bit_num
00AE E0                MOVX    A,@DPTR
00AF A2E7              MOV     C,ACC.7
00B1 13                RRC     A
00B2 F0                MOVX    @DPTR,A
00B3 A3                INC     DPTR
00B4 E0                MOVX    A,@DPTR
00B5 13                RRC     A
00B6 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1054
00B7 809D              SJMP    ?C0145
                                           ; SOURCE LINE # 1055
00B9         ?C0152:
00B9 22                RET     
             ; FUNCTION _CheckExtendKeys (END)
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 66  


             ; FUNCTION _ExtendKeyDebounce (BEGIN)
                                           ; SOURCE LINE # 1060
;---- Variable 'KSI_bit_num' assigned to Register 'R7' ----
;---- Variable 'event' assigned to Register 'R3' ----
;---- Variable 'scan_address' assigned to Register 'R5' ----
                                           ; SOURCE LINE # 1061
                                           ; SOURCE LINE # 1062
0000 ED                MOV     A,R5
0001 24F0              ADD     A,#0F0H
0003 540F              ANL     A,#0FH
0005 C4                SWAP    A
0006 54F0              ANL     A,#0F0H
0008 FE                MOV     R6,A
0009 E500        E     MOV     A,new_extendkey
000B 540F              ANL     A,#0FH
000D 4E                ORL     A,R6
000E F500        E     MOV     new_extendkey,A
                                           ; SOURCE LINE # 1063
0010 EF                MOV     A,R7
0011 5407              ANL     A,#07H
0013 FF                MOV     R7,A
0014 E500        E     MOV     A,new_extendkey
0016 54F8              ANL     A,#0F8H
0018 4F                ORL     A,R7
0019 F500        E     MOV     new_extendkey,A
                                           ; SOURCE LINE # 1064
001B 430008      E     ORL     new_extendkey,#08H
                                           ; SOURCE LINE # 1065
001E 5300FE      E     ANL     extendstatus,#0FEH
                                           ; SOURCE LINE # 1066
0021 5300EF      E     ANL     extendstatus,#0EFH
                                           ; SOURCE LINE # 1068
0024 EB                MOV     A,R3
0025 7005              JNZ     ?C0153
                                           ; SOURCE LINE # 1069
                                           ; SOURCE LINE # 1070
0027 5300FD      E     ANL     extendstatus,#0FDH
                                           ; SOURCE LINE # 1071
                                           ; SOURCE LINE # 1072
002A 8003              SJMP    ?C0221
002C         ?C0153:
                                           ; SOURCE LINE # 1074
                                           ; SOURCE LINE # 1075
002C 430002      E     ORL     extendstatus,#02H
                                           ; SOURCE LINE # 1076
002F         ?C0221:
002F E500        E     MOV     A,extendstatus
0031 541F              ANL     A,#01FH
0033 4420              ORL     A,#020H
0035 F500        E     MOV     extendstatus,A
                                           ; SOURCE LINE # 1077
                                           ; SOURCE LINE # 1078
0037         ?C0155:
0037 22                RET     
             ; FUNCTION _ExtendKeyDebounce (END)

             ; FUNCTION DebounceExtendkey (BEGIN)
                                           ; SOURCE LINE # 1081
                                           ; SOURCE LINE # 1082
                                           ; SOURCE LINE # 1083
0000 AF00        E     MOV     R7,new_extendkey
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 67  

0002 EF                MOV     A,R7
0003 C4                SWAP    A
0004 540F              ANL     A,#0FH
0006 FF                MOV     R7,A
0007 120000      R     LCALL   _SetExtendScanLines
                                           ; SOURCE LINE # 1084
000A 120000      R     LCALL   Read_Scan_Lines
000D 8F00        E     MOV     ITempB04,R7
                                           ; SOURCE LINE # 1085
000F 6300FF      E     XRL     ITempB04,#0FFH
                                           ; SOURCE LINE # 1086
0012 E500        E     MOV     A,new_extendkey
0014 120000      R     LCALL   L?0228
0017 8002              SJMP    ?C0210
0019         ?C0209:
0019 C3                CLR     C
001A 33                RLC     A
001B         ?C0210:
001B D8FC              DJNZ    R0,?C0209
001D F500        E     MOV     ITempB05,A
                                           ; SOURCE LINE # 1087
001F E500        E     MOV     A,ITempB04
0021 5200        E     ANL     ITempB05,A
                                           ; SOURCE LINE # 1089
0023 E500        E     MOV     A,ITempB05
0025 6007              JZ      ?C0156
                                           ; SOURCE LINE # 1090
                                           ; SOURCE LINE # 1091
0027 E500        E     MOV     A,extendstatus
0029 20E107            JB      ACC.1,?C0223
                                           ; SOURCE LINE # 1092
                                           ; SOURCE LINE # 1093
                                           ; SOURCE LINE # 1094
002C 800A              SJMP    ?C0222
002E         ?C0156:
                                           ; SOURCE LINE # 1101
                                           ; SOURCE LINE # 1102
002E E500        E     MOV     A,extendstatus
0030 20E105            JB      ACC.1,?C0160
                                           ; SOURCE LINE # 1103
                                           ; SOURCE LINE # 1104
0033         ?C0223:
0033 5300EF      E     ANL     extendstatus,#0EFH
                                           ; SOURCE LINE # 1105
0036 8003              SJMP    ?C0159
0038         ?C0160:
                                           ; SOURCE LINE # 1107
                                           ; SOURCE LINE # 1108
0038         ?C0222:
0038 430010      E     ORL     extendstatus,#010H
                                           ; SOURCE LINE # 1109
                                           ; SOURCE LINE # 1110
003B         ?C0159:
                                           ; SOURCE LINE # 1112
003B E500        E     MOV     A,extendstatus
003D 20E02C            JB      ACC.0,?C0162
                                           ; SOURCE LINE # 1113
                                           ; SOURCE LINE # 1114
0040 AF00        E     MOV     R7,extendstatus
0042 EF                MOV     A,R7
0043 C4                SWAP    A
0044 13                RRC     A
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 68  

0045 5407              ANL     A,#07H
0047 6018              JZ      ?C0163
                                           ; SOURCE LINE # 1115
                                           ; SOURCE LINE # 1116
0049 AF00        E     MOV     R7,extendstatus
004B EF                MOV     A,R7
004C C4                SWAP    A
004D 13                RRC     A
004E 5407              ANL     A,#07H
0050 FE                MOV     R6,A
0051 EF                MOV     A,R7
0052 541F              ANL     A,#01FH
0054 FF                MOV     R7,A
0055 EE                MOV     A,R6
0056 14                DEC     A
0057 5407              ANL     A,#07H
0059 C4                SWAP    A
005A 33                RLC     A
005B 54E0              ANL     A,#0E0H
005D 4F                ORL     A,R7
005E F500        E     MOV     extendstatus,A
                                           ; SOURCE LINE # 1117
0060 22                RET     
0061         ?C0163:
                                           ; SOURCE LINE # 1119
                                           ; SOURCE LINE # 1120
0061 E500        E     MOV     A,extendstatus
0063 20E402            JB      ACC.4,?C0165
                                           ; SOURCE LINE # 1121
                                           ; SOURCE LINE # 1122
                                           ; SOURCE LINE # 1123
                                           ; SOURCE LINE # 1124
0066 8009              SJMP    ?C0224
0068         ?C0165:
                                           ; SOURCE LINE # 1126
                                           ; SOURCE LINE # 1127
0068 430001      E     ORL     extendstatus,#01H
                                           ; SOURCE LINE # 1128
                                           ; SOURCE LINE # 1129
                                           ; SOURCE LINE # 1130
006B 22                RET     
006C         ?C0162:
                                           ; SOURCE LINE # 1132
                                           ; SOURCE LINE # 1133
006C E500        E     MOV     A,extendstatus
006E 20E406            JB      ACC.4,?C0168
                                           ; SOURCE LINE # 1134
                                           ; SOURCE LINE # 1135
0071         ?C0224:
0071 E4                CLR     A
0072 F500        E     MOV     new_extendkey,A
                                           ; SOURCE LINE # 1136
0074 F500        E     MOV     extendstatus,A
                                           ; SOURCE LINE # 1137
0076 22                RET     
0077         ?C0168:
                                           ; SOURCE LINE # 1139
                                           ; SOURCE LINE # 1140
0077 120000      R     LCALL   CheckExtendKeyValid
                                           ; SOURCE LINE # 1141
                                           ; SOURCE LINE # 1142
                                           ; SOURCE LINE # 1143
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 69  

007A         ?C0170:
007A 22                RET     
             ; FUNCTION DebounceExtendkey (END)

             ; FUNCTION CheckExtendKeyValid (BEGIN)
                                           ; SOURCE LINE # 1149
                                           ; SOURCE LINE # 1150
                                           ; SOURCE LINE # 1151
0000 E500        E     MOV     A,new_extendkey
0002 120000      R     LCALL   L?0228
0005 8002              SJMP    ?C0212
0007         ?C0211:
0007 C3                CLR     C
0008 33                RLC     A
0009         ?C0212:
0009 D8FC              DJNZ    R0,?C0211
000B F500        E     MOV     ITempB02,A
                                           ; SOURCE LINE # 1152
000D 120000      R     LCALL   L?0245
0010 E6                MOV     A,@R0
0011 F500        E     MOV     ITempB01,A
                                           ; SOURCE LINE # 1153
0013 E500        E     MOV     A,ITempB02
0015 6200        E     XRL     ITempB01,A
                                           ; SOURCE LINE # 1154
0017 120000      R     LCALL   L?0245
001A A600        E     MOV     @R0,ITempB01
                                           ; SOURCE LINE # 1156
001C 750001      E     MOV     ITempB03,#01H
                                           ; SOURCE LINE # 1157
001F E500        E     MOV     A,ITempB02
0021 5500        E     ANL     A,ITempB01
0023 6013              JZ      ?C0171
                                           ; SOURCE LINE # 1158
                                           ; SOURCE LINE # 1159
0025 E4                CLR     A
0026 F500        E     MOV     ITempB03,A
                                           ; SOURCE LINE # 1160
0028 850000      E     MOV     etkeytypematic,new_extendkey
                                           ; SOURCE LINE # 1161
002B E500        E     MOV     A,extendscan+01H
002D 540F              ANL     A,#0FH
002F 4420              ORL     A,#020H
0031 F500        E     MOV     extendscan+01H,A
                                           ; SOURCE LINE # 1162
                                           ; SOURCE LINE # 1164
0033 120000      R     LCALL   L?0250
0036 F500        E     MOV     typematic,A
                                           ; SOURCE LINE # 1165
0038         ?C0171:
                                           ; SOURCE LINE # 1167
0038 7800        R     MOV     R0,#LOW ?Send_EtScan2?BYTE
003A 7C00        R     MOV     R4,#HIGH ?Send_EtScan2?BYTE
003C 7D01              MOV     R5,#01H
003E 7B00              MOV     R3,#00H
0040 7A00        E     MOV     R2,#HIGH new_extendkey
0042 7900        E     MOV     R1,#LOW new_extendkey
0044 120000      R     LCALL   L?0230
0047 900000      R     MOV     DPTR,#?Send_EtScan2?BYTE+01H
004A E500        E     MOV     A,ITempB03
004C F0                MOVX    @DPTR,A
004D 120000      R     LCALL   Send_EtScan2
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 70  

                                           ; SOURCE LINE # 1168
0050 E4                CLR     A
0051 F500        E     MOV     new_extendkey,A
                                           ; SOURCE LINE # 1169
0053 F500        E     MOV     extendstatus,A
                                           ; SOURCE LINE # 1170
0055 22                RET     
             ; FUNCTION CheckExtendKeyValid (END)

             ; FUNCTION Send_EtScan2 (BEGIN)
                                           ; SOURCE LINE # 1175
                                           ; SOURCE LINE # 1176
                                           ; SOURCE LINE # 1177
0000 900000      E     MOV     DPTR,#UtilityFlag
0003 E0                MOVX    A,@DPTR
0004 30E626            JNB     ACC.6,?C0173
                                           ; SOURCE LINE # 1178
                                           ; SOURCE LINE # 1179
0007 900000      E     MOV     DPTR,#KeyScanACK
000A E0                MOVX    A,@DPTR
000B F4                CPL     A
000C 7059              JNZ     ?C0177
                                           ; SOURCE LINE # 1180
                                           ; SOURCE LINE # 1181
000E 900000      R     MOV     DPTR,#event
0011 E0                MOVX    A,@DPTR
0012 7053              JNZ     ?C0177
                                           ; SOURCE LINE # 1182
                                           ; SOURCE LINE # 1183
0014 120000      R     LCALL   L?0254
0017 900000      E     MOV     DPTR,#KeyScanKSI
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1184
001B 900000      R     MOV     DPTR,#key
001E E0                MOVX    A,@DPTR
001F C4                SWAP    A
0020 540F              ANL     A,#0FH
0022 900000      E     MOV     DPTR,#KeyScanKSO
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1185
0026 900000      E     MOV     DPTR,#KeyScanACK
0029 7444              MOV     A,#044H
002B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1186
                                           ; SOURCE LINE # 1187
                                           ; SOURCE LINE # 1188
002C 22                RET     
002D         ?C0173:
                                           ; SOURCE LINE # 1190
                                           ; SOURCE LINE # 1191
002D 120000      R     LCALL   L?0254
0030 75F003            MOV     B,#03H
0033 A4                MUL     AB
0034 FF                MOV     R7,A
0035 E0                MOVX    A,@DPTR
0036 C4                SWAP    A
0037 540F              ANL     A,#0FH
0039 2F                ADD     A,R7
003A F500        E     MOV     ITempB02,A
                                           ; SOURCE LINE # 1192
003C AF00        E     MOV     R7,ITempB02
003E 900000      E     MOV     DPTR,#Extendkey_Table_Pntr
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 71  

0041 E0                MOVX    A,@DPTR
0042 FC                MOV     R4,A
0043 A3                INC     DPTR
0044 E0                MOVX    A,@DPTR
0045 2F                ADD     A,R7
0046 F582              MOV     DPL,A
0048 E4                CLR     A
0049 3C                ADDC    A,R4
004A F583              MOV     DPH,A
004C E4                CLR     A
004D 93                MOVC    A,@A+DPTR
004E F500        E     MOV     ITempB01,A
                                           ; SOURCE LINE # 1194
0050 120000      R     LCALL   L?0255
0053 FF                MOV     R7,A
0054 E0                MOVX    A,@DPTR
0055 FE                MOV     R6,A
0056 C4                SWAP    A
0057 540F              ANL     A,#0FH
0059 FD                MOV     R5,A
005A 120000      E     LCALL   _Et_Hook_keyboard
                                           ; SOURCE LINE # 1195
005D 900000      R     MOV     DPTR,#event
0060 E0                MOVX    A,@DPTR
0061 FD                MOV     R5,A
0062 AF00        E     MOV     R7,ITempB01
0064 120000      E     LCALL   _Send_Key
                                           ; SOURCE LINE # 1196
                                           ; SOURCE LINE # 1197
0067         ?C0177:
0067 22                RET     
             ; FUNCTION Send_EtScan2 (END)

             ; FUNCTION ClearExtendKeys (BEGIN)
                                           ; SOURCE LINE # 1202
                                           ; SOURCE LINE # 1203
                                           ; SOURCE LINE # 1204
0000 E4                CLR     A
0001 F500        E     MOV     new_extendkey,A
                                           ; SOURCE LINE # 1205
0003 F500        E     MOV     extendstatus,A
                                           ; SOURCE LINE # 1206
0005 F500        E     MOV     etkeytypematic,A
                                           ; SOURCE LINE # 1207
0007 22                RET     
             ; FUNCTION ClearExtendKeys (END)

             ; FUNCTION CheckEtKeystm (BEGIN)
                                           ; SOURCE LINE # 1212
                                           ; SOURCE LINE # 1213
                                           ; SOURCE LINE # 1214
0000 E4                CLR     A
0001 F500        E     MOV     ITempB02,A
                                           ; SOURCE LINE # 1215
0003 900000      R     MOV     DPTR,#key
0006 E0                MOVX    A,@DPTR
0007 120000      R     LCALL   L?0228
000A 8002              SJMP    ?C0214
000C         ?C0213:
000C C3                CLR     C
000D 33                RLC     A
000E         ?C0214:
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 72  

000E D8FC              DJNZ    R0,?C0213
0010 F500        E     MOV     ITempB01,A
                                           ; SOURCE LINE # 1216
0012 900000      R     MOV     DPTR,#key
0015 E0                MOVX    A,@DPTR
0016 120000      R     LCALL   L?0246
0019 E6                MOV     A,@R0
001A 5200        E     ANL     ITempB01,A
                                           ; SOURCE LINE # 1218
001C E500        E     MOV     A,ITempB01
001E 7005              JNZ     ?C0179
                                           ; SOURCE LINE # 1219
                                           ; SOURCE LINE # 1220
0020 F500        E     MOV     etkeytypematic,A
                                           ; SOURCE LINE # 1221
0022 750001      E     MOV     ITempB02,#01H
                                           ; SOURCE LINE # 1222
0025         ?C0179:
                                           ; SOURCE LINE # 1224
0025 E500        E     MOV     A,ITempB02
0027 700F              JNZ     ?C0180
                                           ; SOURCE LINE # 1225
                                           ; SOURCE LINE # 1226
0029 AF00        E     MOV     R7,extendscan+01H
002B 120000      R     LCALL   L?0231
002E F500        E     MOV     extendscan+01H,A
                                           ; SOURCE LINE # 1227
0030 C4                SWAP    A
0031 540F              ANL     A,#0FH
0033 6003              JZ      ?C0180
                                           ; SOURCE LINE # 1228
                                           ; SOURCE LINE # 1229
0035 750001      E     MOV     ITempB02,#01H
                                           ; SOURCE LINE # 1230
                                           ; SOURCE LINE # 1231
0038         ?C0180:
                                           ; SOURCE LINE # 1233
0038 E500        E     MOV     A,ITempB02
003A 7014              JNZ     ?C0182
                                           ; SOURCE LINE # 1234
                                           ; SOURCE LINE # 1235
003C E500        E     MOV     A,extendscan+01H
003E 540F              ANL     A,#0FH
0040 4420              ORL     A,#020H
0042 F500        E     MOV     extendscan+01H,A
                                           ; SOURCE LINE # 1236
0044 900000      E     MOV     DPTR,#bTMcount
0047 E0                MOVX    A,@DPTR
0048 14                DEC     A
0049 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1237
004A E0                MOVX    A,@DPTR
004B 6003              JZ      ?C0182
                                           ; SOURCE LINE # 1238
                                           ; SOURCE LINE # 1239
004D 750001      E     MOV     ITempB02,#01H
                                           ; SOURCE LINE # 1240
                                           ; SOURCE LINE # 1241
0050         ?C0182:
                                           ; SOURCE LINE # 1243
0050 E500        E     MOV     A,ITempB02
0052 7020              JNZ     ?C0185
C51 COMPILER V9.03   CORE_SCAN                                                             02/02/2015 14:30:13 PAGE 73  

                                           ; SOURCE LINE # 1244
                                           ; SOURCE LINE # 1245
0054 900000      E     MOV     DPTR,#bTMrepeat
0057 E0                MOVX    A,@DPTR
0058 900000      E     MOV     DPTR,#bTMcount
005B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1246
005C 7800        R     MOV     R0,#LOW ?Send_EtScan2?BYTE
005E 7C00        R     MOV     R4,#HIGH ?Send_EtScan2?BYTE
0060 7D01              MOV     R5,#01H
0062 7B01              MOV     R3,#01H
0064 7A00        R     MOV     R2,#HIGH key
0066 7900        R     MOV     R1,#LOW key
0068 120000      R     LCALL   L?0230
006B 900000      R     MOV     DPTR,#?Send_EtScan2?BYTE+01H
006E 7402              MOV     A,#02H
0070 F0                MOVX    @DPTR,A
0071 120000      R     LCALL   Send_EtScan2
                                           ; SOURCE LINE # 1247
                                           ; SOURCE LINE # 1248
0074         ?C0185:
0074 22                RET     
             ; FUNCTION CheckEtKeystm (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2629    ----
   CONSTANT SIZE    =     36    ----
   XDATA SIZE       =   ----      26
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
